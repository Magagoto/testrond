<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Modèle 3D réactif à la marche</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- Import de la librairie <model-viewer> -->
<script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
<style>
body {
  margin: 0;
  background-color: #0b042d;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  flex-direction: column;
  font-family: sans-serif;
}
model-viewer {
  width: 100%;
  max-width: 800px;
  height: 600px;
  background: transparent;
}
.info-row {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 24px;
  margin-bottom: 32px;
  width: 100%;
  max-width: 800px;
}
.info-rect {
  flex: 1 1 0;
  min-width: 120px;
  background: rgba(255,255,255,0.13);
  color: #f5f6fa;
  border-radius: 18px;
  padding: 20px 14px;
  font-size: 1.13rem;
  font-weight: 600;
  text-align: center;
  box-shadow: 0 4px 18px rgba(11,4,45,0.10), 0 1.5px 6px rgba(0,0,0,0.09);
  border: 1.5px solid rgba(255,255,255,0.18);
  min-height: 54px;
  display: flex;
  align-items: center;
  justify-content: center;
  letter-spacing: 0.01em;
  transition: background 0.2s, box-shadow 0.2s, color 0.2s;
  backdrop-filter: blur(2px);
}
.info-rect:not(:empty):hover {
  background: rgba(255,255,255,0.22);
  color: #0b042d;
  box-shadow: 0 6px 24px rgba(11,4,45,0.18);
  cursor: pointer;
}
.info-rect:empty {
  background: rgba(255,255,255,0.07);
  border-style: dashed;
  border-color: rgba(255,255,255,0.13);
  cursor: default;
  pointer-events: none;
}
.instructions {
  color: #f5f6fa;
  font-size: 1rem;
  text-align: center;
  margin-top: 20px;
  max-width: 600px;
  padding: 0 20px;
}
.debug-info {
  position: fixed;
  bottom: 10px;
  left: 10px;
  color: rgba(255,255,255,0.6);
  font-size: 0.8rem;
  font-family: monospace;
  background: rgba(0,0,0,0.3);
  padding: 5px;
  border-radius: 5px;
  max-width: 300px;
  display: none; /* Masqué par défaut */
}
</style>
</head>
<body>
<div class="info-row">
  <div class="info-rect" id="distanceInfo">marche en cours: 8km</div>
  <div class="info-rect" id="timeInfo">temps restant: 9 minutes</div>
  <div class="info-rect" id="stepsInfo">pas: 0</div>
  <div class="info-rect" id="statusInfo">Toucher pour démarrer</div>
</div>
<!-- Modèle 3D sans fond blanc -->
<model-viewer
  id="modelViewer"
  src="GLB/final.glb"
  alt="Modèle 3D interactif"
  auto-rotate
  camera-controls
  disable-zoom>
</model-viewer>

<p class="instructions">Marchez avec votre appareil. La vitesse de rotation du modèle s'adaptera à votre allure.</p>

<div class="debug-info" id="debugInfo"></div>

<script>
  // Éléments d'interface
  const modelViewer = document.getElementById('modelViewer');
  const distanceInfo = document.getElementById('distanceInfo');
  const timeInfo = document.getElementById('timeInfo');
  const stepsInfo = document.getElementById('stepsInfo');
  const statusInfo = document.getElementById('statusInfo');
  const debugInfo = document.getElementById('debugInfo');
  
  // Variables pour la détection de la marche
  let isTracking = false;
  let walkingSpeed = 0;
  let stepCount = 0;
  let lastStepTime = 0;
  let inStep = false;
  
  // Tableau pour stocker les dernières valeurs d'accélération
  let accelerationValues = [];
  const MAX_ACCELERATION_VALUES = 30;
  
  // Variables pour la détection des pas
  let lastAcceleration = 0;
  let peakDetected = false;
  let valleyDetected = false;
  let lastPeakTime = 0;
  
  // Constantes pour le contrôle de la rotation
  const MIN_ROTATION_SPEED = 0.2;  // Vitesse minimale de rotation (tours par minute)
  const MAX_ROTATION_SPEED = 3.0;  // Vitesse maximale de rotation (tours par minute)
  
  // Valeurs ajustables pour la détection de la marche
  const STEP_THRESHOLD = 1.3;      // Seuil pour détecter un pas
  const MIN_STEP_INTERVAL = 200;   // Intervalle minimum entre les pas (ms)
  const WALKING_TIMEOUT = 2000;    // Temps après lequel on considère que la marche est arrêtée (ms)
  
  // Rotation initiale lente
  modelViewer.setAttribute('rotation-per-second', `${MIN_ROTATION_SPEED * 360 / 60}deg`);

  // Fonction pour gérer les pas détectés
  function handleStep() {
    const now = Date.now();
    
    // Éviter les faux positifs en vérifiant l'intervalle entre les pas
    if (now - lastStepTime < MIN_STEP_INTERVAL) {
      return;
    }
    
    // Incrémenter le compteur de pas
    stepCount++;
    lastStepTime = now;
    
    // Calculer la vitesse de marche (pas par minute)
    const stepInterval = now - lastStepTime;
    if (stepInterval > 0) {
      // Calculer approximativement les pas par minute
      walkingSpeed = 60000 / stepInterval;
    }
    
    // Mise à jour de l'interface
    stepsInfo.textContent = `pas: ${stepCount}`;
    updateModel();
  }
  
  // Fonction qui met à jour la rotation du modèle
  function updateModel() {
    // Obtenir le temps actuel
    const now = Date.now();
    
    // Vérifier si la personne est toujours en train de marcher
    if (now - lastStepTime > WALKING_TIMEOUT) {
      walkingSpeed = 0;
      statusInfo.textContent = "Inactif";
    } else {
      statusInfo.textContent = "Marche détectée";
    }
    
    // Calculer la vitesse de rotation en fonction de la vitesse de marche
    let rotationSpeed;
    
    if (walkingSpeed > 0) {
      // Limiter la vitesse de marche entre 30 et 180 pas par minute
      const normalizedSpeed = Math.min(Math.max(walkingSpeed, 30), 180);
      
      // Calculer la vitesse de rotation proportionnelle
      const factor = (normalizedSpeed - 30) / (180 - 30);
      rotationSpeed = MIN_ROTATION_SPEED + factor * (MAX_ROTATION_SPEED - MIN_ROTATION_SPEED);
    } else {
      // Rotation lente quand pas de mouvement
      rotationSpeed = MIN_ROTATION_SPEED;
    }
    
    // Convertir tours par minute en degrés par seconde
    const rotationDegPerSec = rotationSpeed * 360 / 60;
    
    // Appliquer la rotation au modèle 3D
    modelViewer.setAttribute('rotation-per-second', `${rotationDegPerSec}deg`);
    
    // Simuler la progression de la marche
    if (walkingSpeed > 0) {
      // Calculer distance approximative parcourue
      const distancePerStep = 0.0007; // environ 0.7m par pas
      const distanceKm = (stepCount * distancePerStep).toFixed(2);
      distanceInfo.textContent = `marche en cours: ${distanceKm}km`;
      
      // Estimer le temps restant
      const remainingDistance = 8 - distanceKm;
      if (remainingDistance > 0 && walkingSpeed > 0) {
        // Conversion pas par minute en km/h approximatif
        const kmPerHour = walkingSpeed * 0.042; // conversion approximative
        const remainingHours = remainingDistance / kmPerHour;
        const remainingMinutes = Math.ceil(remainingHours * 60);
        timeInfo.textContent = `temps restant: ${remainingMinutes} minutes`;
      }
    }
  }
  
  // Fonction de traitement des données de l'accéléromètre
  function processMotion(event) {
    if (!isTracking) return;
    
    // Obtenir les données d'accélération
    const acceleration = event.accelerationIncludingGravity || event.acceleration;
    
    if (!acceleration) {
      debugInfo.textContent = "Pas de données d'accélération disponibles";
      return;
    }
    
    // Calculer la magnitude de l'accélération
    const magnitude = Math.sqrt(
      acceleration.x * acceleration.x + 
      acceleration.y * acceleration.y + 
      acceleration.z * acceleration.z
    );
    
    // Ajouter la nouvelle valeur au tableau
    accelerationValues.push(magnitude);
    
    // Limiter la taille du tableau
    if (accelerationValues.length > MAX_ACCELERATION_VALUES) {
      accelerationValues.shift();
    }
    
    // Si nous avons assez de valeurs, analyser le motif pour détecter les pas
    if (accelerationValues.length > 5) {
      const currentAcceleration = magnitude;
      
      // Détection des pics et vallées pour les pas
      if (currentAcceleration > lastAcceleration && currentAcceleration > STEP_THRESHOLD) {
        // Potentiel pic détecté
        peakDetected = true;
        valleyDetected = false;
      } else if (currentAcceleration < lastAcceleration && peakDetected) {
        // Potentielle vallée après un pic
        valleyDetected = true;
      }
      
      // Un pas est détecté lorsqu'on a un pic suivi d'une vallée
      if (peakDetected && valleyDetected) {
        handleStep();
        peakDetected = false;
        valleyDetected = false;
      }
      
      lastAcceleration = currentAcceleration;
    }
    
    // Debug: afficher les données d'accélération
    debugInfo.textContent = `Acc: ${magnitude.toFixed(2)}, Seuil: ${STEP_THRESHOLD}, Vitesse: ${walkingSpeed.toFixed(1)} pas/min`;
  }
  
  // Fonction pour démarrer le suivi
  function startTracking() {
    if (window.DeviceMotionEvent !== undefined) {
      // Afficher les informations de débogage
      debugInfo.style.display = "block";
      
      // Vérifier si l'API nécessite une autorisation (iOS 13+)
      if (typeof DeviceMotionEvent.requestPermission === 'function') {
        DeviceMotionEvent.requestPermission()
          .then(permissionState => {
            if (permissionState === 'granted') {
              window.addEventListener('devicemotion', processMotion);
              isTracking = true;
              statusInfo.textContent = "Actif (iOS)";
            } else {
              statusInfo.textContent = "Permission refusée";
            }
          })
          .catch(error => {
            statusInfo.textContent = "Erreur: " + error;
          });
      } else {
        // Pour Android et autres
        window.addEventListener('devicemotion', processMotion);
        isTracking = true;
        statusInfo.textContent = "Actif";
      }
    } else {
      statusInfo.textContent = "Non supporté";
    }
  }
  
  // Fonction pour arrêter le suivi
  function stopTracking() {
    if (isTracking) {
      window.removeEventListener('devicemotion', processMotion);
      isTracking = false;
      statusInfo.textContent = "Toucher pour démarrer";
      debugInfo.style.display = "none";
    }
  }
  
  // Ajouter un événement pour basculer le suivi
  statusInfo.addEventListener('click', function() {
    if (isTracking) {
      stopTracking();
    } else {
      startTracking();
    }
  });
  
  // Mise à jour de l'interface à intervalles réguliers
  setInterval(updateModel, 1000);
  
  // Ajouter un événement pour activer le mode débogage
  modelViewer.addEventListener('click', function() {
    debugInfo.style.display = debugInfo.style.display === "none" ? "block" : "none";
  });
  
  // Gérer le cas où la page est en arrière-plan
  document.addEventListener('visibilitychange', function() {
    if (document.hidden && isTracking) {
      stopTracking();
    }
  });
</script>
</body>
</html>