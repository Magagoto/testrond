<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Grille + rectangle central avec CGU</title>
<style>
@font-face {
  font-family: 'AMORIA';
  src: url('AMORIA.otf') format('opentype');
  font-weight: normal;
  font-style: normal;
}
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden !important;
  background: #07114d;
  /* Empêche le scroll sur mobile */
  touch-action: none;
}
body {
  width: 100vw;
  height: 100vh;
  position: relative;
  overflow: hidden !important;
  /* Désactive le scroll */
  overscroll-behavior: none;
}
#canvas {
  position: absolute;
  inset: 0;
  width: 100vw;
  height: 100vh;
  z-index: 0;
  display: block;
}
.center-rect {
  position: absolute;
  left: 50%;
  top: 50%;
  width: 340px;
  height: 270px;
  background: #07114d; /* même couleur que le fond de page */
  border: 2.5px solid #fff;
  box-shadow: 0 8px 32px 0 rgba(0,0,0,0.22), 0 1.5px 16px 0 rgba(62,95,255,0.10);
  border-radius: 22px;
  transform: translate(-50%, -50%);
  z-index: 2;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  padding: 22px 28px 18px 28px;
  box-sizing: border-box;
  font-family: 'Inter', Arial, sans-serif;
  color: #fff;
  overflow: hidden; /* Désactive le scroll dans le CGU */
  backdrop-filter: blur(12px) saturate(1.3);
  transition: box-shadow 0.3s, border 0.3s, background 0.3s;
}

/* Scrollbar stylisée pour le rectangle CGU */
.center-rect::-webkit-scrollbar {
  width: 6px;
  background: transparent;
}
.center-rect::-webkit-scrollbar-thumb {
  background: linear-gradient(135deg, #ff5eae 0%, #ff94d6 100%);
  border-radius: 10px;
  min-height: 28px;
  box-shadow: 0 2px 8px #ff5eae33;
  border: 1.5px solid #fff3;
}
.center-rect::-webkit-scrollbar-thumb:hover {
  background: linear-gradient(135deg, #ff94d6 0%, #ff5eae 100%);
}
.center-rect::-webkit-scrollbar-track {
  background: #07114d;
  border-radius: 10px;
}
.center-rect {
  scrollbar-width: thin;
  scrollbar-color: #ff5eae #07114d;
}

.center-rect h1 {
  font-family: 'AMORIA', serif;
  font-size: 2.2em;
  margin-bottom: 10px;
  margin-top: 2px;
  letter-spacing: 0.08em;
  text-align: center;
  color: #fff;
  text-shadow: 0 2px 12px #0006, 0 1px 0 #fff2;
  font-weight: 700;
  /* plus de chrome, style sobre et élégant */
}

.center-rect h2 {
  font-size: 1.13em;
  margin-top: 10px;
  margin-bottom: 12px;
  font-family: 'Inter', Arial, sans-serif;
  font-weight: 700;
  color: #fff;
  letter-spacing: 0.04em;
  text-shadow: 0 1px 8px #0002;
  border-bottom: 1.5px solid #fff2;
  padding-bottom: 6px;
  width: 100%;
  text-align: center;
}

.center-rect p {
  font-size: 1em;
  text-align: center;
  margin: 12px 0 8px 0;
  line-height: 1.6;
  font-family: 'Inter', Arial, sans-serif;
  color: #e3e8ff;
  text-shadow: 0 1px 8px #0002;
}

#cgu-buttons {
  display: flex;
  gap: 18px;
  margin-top: 20px;
}

.cgu-button {
  background: #fff;
  color: #222b4d;
  border: none;
  border-radius: 7px;
  padding: 10px 26px;
  font-family: 'Inter', Arial, sans-serif;
  font-size: 1em;
  font-weight: 700;
  cursor: pointer;
  box-shadow: 0 2px 8px 0 #0002;
  transition: background 0.2s, box-shadow 0.2s, transform 0.15s, color 0.2s;
  outline: none;
}

.cgu-button:hover, .cgu-button:focus {
  background: #222b4d;
  color: #fff;
  box-shadow: 0 4px 16px 0 #0004;
  transform: translateY(-2px) scale(1.04);
}

@media (max-width: 600px) {
  .center-rect {
    width: 90vw;
    max-width: 98vw;
    height: auto;
    min-height: 120px;
    padding: 12px 8px 8px 8px;
    border-radius: 14px;
    /* Ajout pour remonter le cadre sur mobile */
    top: 44%;
    transform: translate(-50%, -44%);
  }
  .center-rect h1 {
    font-size: 1.3em;
    margin-bottom: 7px;
  }
  .center-rect h2 {
    font-size: 0.95em;
    margin-top: 4px;
    margin-bottom: 6px;
    padding-bottom: 3px;
  }
  .center-rect p {
    font-size: 0.8em;
    line-height: 1.3;
  }
  .cgu-button {
    font-size: 0.85em;
    padding: 7px 12px;
  }
  #cgu-buttons {
    gap: 8px;
    margin-top: 10px;
  }
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<audio id="backgroundMusic" src="SONORE/ambiance page principale.mp3" loop preload="auto" autoplay></audio>
<div class="center-rect">
  <h1>Chroméa</h1>
  <h2>Conditions Générales d'Utilisation</h2>
  <p>En accédant à cette animation, vous acceptez les conditions suivantes :<br>
   Il s'agit d'une expérience visuelle générative à titre expérimental.<br>
   Aucune donnée personnelle n'est collectée.</p>
  <div id="cgu-buttons">
    <button class="cgu-button" onclick="acceptCGU()">Accepter</button>
    <button class="cgu-button" onclick="refuseCGU()">Refuser</button>
  </div>
</div>
<!-- Vérification : il n'y a qu'un seul rectangle central (center-rect) affiché.
Aucun autre rectangle ou div superposée n'est présent dans le HTML. 
Si tu vois un rectangle en dessous, il s'agit probablement d'un effet visuel du canvas ou du CSS (ombre portée, etc.).
Aucune modification n'est nécessaire pour supprimer un rectangle supplémentaire, car il n'y en a pas dans le code. -->

<script>
// Fonction pour gérer l'acceptation des CGU
function acceptCGU() {
  window.location.href = "jeu.html";
  // Pour lancer la musique sur la page CGU si besoin :
  // document.getElementById('backgroundMusic').play();
}

// Fonction pour gérer le refus des CGU
function refuseCGU() {
  alert("Vous devez accepter les CGU pour accéder à l'expérience.");
}

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
// Configuration responsive
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
// Ajuster la taille des cercles en fonction du dispositif
const baseRadius = isMobile ? 16 : 22; // Agrandir les ronds
let radius = baseRadius;
let diameter = radius * 2;
const colors = ["#00A993", "#E68B4A", "#7A1619", "#362777", "#EB7AAE",
"#0069AA", "#DC0C15", "#E03A8D", "#FFFFFF", "#2A4899"];
const gradientMap = {
  "#00A993": "#E68B4A", "#E68B4A": "#7A1619", "#7A1619": "#362777",
  "#362777": "#EB7AAE", "#EB7AAE": "#0069AA", "#0069AA": "#DC0C15",
  "#DC0C15": "#E03A8D", "#E03A8D": "#FFFFFF", "#FFFFFF": "#2A4899",
  "#2A4899": "#00A993"
};
let colorGrid = [];
let appearingZones = []; // Liste des zones de cercles à afficher progressivement
let currentZoneIndexTop = 0;
let currentZoneIndexBottom = 0;
let currentCircleIndexTop = 0;
let currentCircleIndexBottom = 0;

function resizeCanvas() {
  const dpr = window.devicePixelRatio || 1; // Récupérer le ratio de pixels de l'appareil
  canvas.width = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;
  canvas.style.width = `${window.innerWidth}px`;
  canvas.style.height = `${window.innerHeight}px`;
  ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform avant scale
  ctx.scale(dpr, dpr); // Adapter le contexte au ratio de pixels

  // Ajuster dynamiquement le rayon en fonction de la taille de l'écran
  if (isMobile) {
    const desiredCirclesWidth = window.innerWidth < 380 ? 12 : 15;
    radius = Math.min(16, Math.floor(window.innerWidth / desiredCirclesWidth / 2));
  } else {
    radius = baseRadius;
  }
  diameter = radius * 2;

  // Utiliser un pas de radius pour coller les cercles
  const cols = Math.ceil(window.innerWidth / radius) + 2;
  const rows = Math.ceil(window.innerHeight / radius) + 2;

  colorGrid = new Array(rows).fill().map(() => new Array(cols).fill(null));
  appearingZones = []; // Réinitialiser la liste des zones
  currentZoneIndexTop = 0;
  currentZoneIndexBottom = 0;
  currentCircleIndexTop = 0;
  currentCircleIndexBottom = 0;

  // Générer la grille et regrouper les cercles par zones de couleur
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const neighbors = getNeighborColors(x, y);
      let chosenColor;

      if (neighbors.length > 0 && Math.random() < 0.8) {
        chosenColor = neighbors[Math.floor(Math.random() * neighbors.length)];
      } else {
        chosenColor = colors[Math.floor(Math.random() * colors.length)];
      }

      colorGrid[y][x] = chosenColor;
    }
  }

  // Identifier les zones de couleur
  const visited = new Set();
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const color = colorGrid[y][x];
      if (color && !visited.has(`${x},${y}`)) {
        const zone = getZone(x, y, color, visited);
        appearingZones.push(zone);
      }
    }
  }
}

function getNeighborColors(cx, cy) {
  const neighborColors = [];
  for (let dy = -1; dy <= 0; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      const nx = cx + dx;
      const ny = cy + dy;
      if (nx >= 0 && ny >= 0 && ny < colorGrid.length && nx < colorGrid[0].length) {
        const color = colorGrid[ny][nx];
        if (color) neighborColors.push(color);
      }
    }
  }
  return neighborColors;
}

function getZone(x, y, targetColor, visited) {
  const queue = [[x, y]];
  const zone = [];

  while (queue.length > 0) {
    const [cx, cy] = queue.shift();
    const key = `${cx},${cy}`;
    if (visited.has(key)) continue;
    visited.add(key);

    if (colorGrid[cy]?.[cx] === targetColor) {
      zone.push({ x: cx, y: cy, color: targetColor });
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx !== 0 || dy !== 0) {
            queue.push([cx + dx, cy + dy]);
          }
        }
      }
    }
  }

  return zone;
}

function isInCenterRect(cx, cy) {
  // Désactivé : autorise les ronds à passer sous le GPU
  return false;
}

function animate(time) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Afficher toutes les zones déjà générées depuis le haut
  for (let i = 0; i < currentZoneIndexTop; i++) {
    const zone = appearingZones[i];
    for (const { x, y, color } of zone) {
      const cx = x * radius;
      const cy = y * radius;
      if (isInCenterRect(cx, cy)) continue;
      const gradient = ctx.createRadialGradient(cx, cy, radius * 0.3, cx, cy, radius);
      gradient.addColorStop(0, color);
      gradient.addColorStop(1, gradientMap[color.toUpperCase()] || color);
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  // Afficher toutes les zones déjà générées depuis le bas
  for (let i = 0; i < currentZoneIndexBottom; i++) {
    const zone = appearingZones[appearingZones.length - 1 - i];
    for (const { x, y, color } of zone) {
      const cx = x * radius;
      const cy = y * radius;
      if (isInCenterRect(cx, cy)) continue;
      const gradient = ctx.createRadialGradient(cx, cy, radius * 0.3, cx, cy, radius);
      gradient.addColorStop(0, color);
      gradient.addColorStop(1, gradientMap[color.toUpperCase()] || color);
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  if (currentZoneIndexTop + currentZoneIndexBottom < appearingZones.length) {
    if (currentZoneIndexTop + currentZoneIndexBottom < appearingZones.length) {
      // Zone du haut
      if (currentZoneIndexTop + currentZoneIndexBottom < appearingZones.length) {
        const zoneTop = appearingZones[currentZoneIndexTop];
        for (let j = 0; j <= currentCircleIndexTop; j++) {
          if (j >= zoneTop.length) break;
          const { x, y, color } = zoneTop[j];
          const cx = x * radius;
          const cy = y * radius;
          if (isInCenterRect(cx, cy)) continue;
          const gradient = ctx.createRadialGradient(cx, cy, radius * 0.3, cx, cy, radius);
          gradient.addColorStop(0, color);
          gradient.addColorStop(1, gradientMap[color.toUpperCase()] || color);
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(cx, cy, radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      // Zone du bas
      if (currentZoneIndexTop + currentZoneIndexBottom < appearingZones.length &&
          appearingZones.length - 1 - currentZoneIndexBottom !== currentZoneIndexTop) {
        const zoneBottom = appearingZones[appearingZones.length - 1 - currentZoneIndexBottom];
        for (let j = 0; j <= currentCircleIndexBottom; j++) {
          if (j >= zoneBottom.length) break;
          const { x, y, color } = zoneBottom[j];
          const cx = x * radius;
          const cy = y * radius;
          if (isInCenterRect(cx, cy)) continue;
          const gradient = ctx.createRadialGradient(cx, cy, radius * 0.3, cx, cy, radius);
          gradient.addColorStop(0, color);
          gradient.addColorStop(1, gradientMap[color.toUpperCase()] || color);
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(cx, cy, radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    // Animation des cercles pour chaque zone (plus rapide : +5 à chaque frame)
    let needNextFrame = false;
    const step = 5; // accélération ici
    if (currentZoneIndexTop + currentZoneIndexBottom < appearingZones.length) {
      const zoneTop = appearingZones[currentZoneIndexTop];
      if (currentCircleIndexTop < zoneTop.length - 1) {
        currentCircleIndexTop += step;
        if (currentCircleIndexTop > zoneTop.length - 1) currentCircleIndexTop = zoneTop.length - 1;
        needNextFrame = true;
      } else if (currentZoneIndexTop + currentZoneIndexBottom < appearingZones.length) {
        currentZoneIndexTop++;
        currentCircleIndexTop = 0;
        needNextFrame = true;
      }
      // Zone du bas
      if (appearingZones.length - 1 - currentZoneIndexBottom !== currentZoneIndexTop) {
        const zoneBottom = appearingZones[appearingZones.length - 1 - currentZoneIndexBottom];
        if (currentCircleIndexBottom < zoneBottom.length - 1) {
          currentCircleIndexBottom += step;
          if (currentCircleIndexBottom > zoneBottom.length - 1) currentCircleIndexBottom = zoneBottom.length - 1;
          needNextFrame = true;
        } else if (currentZoneIndexTop + currentZoneIndexBottom < appearingZones.length) {
          currentZoneIndexBottom++;
          currentCircleIndexBottom = 0;
          needNextFrame = true;
        }
      }
    }
    if (needNextFrame) {
      requestAnimationFrame(animate);
    }
  }
}

// Fonction utilitaire pour limiter les appels de redimensionnement
function debounce(func, wait) {
  let timeout;
  return function() {
    const context = this;
    const args = arguments;
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      func.apply(context, args);
    }, wait);
  };
}

// Essaye de jouer la musique dès que possible
document.getElementById('backgroundMusic').play().catch(() => {});

// Démarrage musique d'ambiance après interaction utilisateur (fallback)
function playMusicOnce() {
  document.getElementById('backgroundMusic').play().catch(() => {});
  window.removeEventListener('pointerdown', playMusicOnce);
  window.removeEventListener('keydown', playMusicOnce);
}
window.addEventListener('pointerdown', playMusicOnce);
window.addEventListener('keydown', playMusicOnce);

// Initialisation
window.addEventListener("load", () => {
  window.addEventListener("resize", debounce(resizeCanvas, 250));
  resizeCanvas();
  requestAnimationFrame(animate);
});
</script>
</body>
</html>