<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
  <title>Zones de ronds regroupés</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: rgb(19, 4, 89);
      touch-action: manipulation;
    }

    canvas {
      display: block;
    }

    #cgu-modal {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.85);
      color: white;
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 9999;
    }

    #cgu-background {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
      pointer-events: none;
    }

    #cgu-content {
      background-color: #1c1c1c;
      padding: 20px;
      border-radius: 10px;
      width: 90%;
      max-width: 600px;
      text-align: center;
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.2);
      z-index: 1;
      font-size: 16px;
    }

    @media (max-width: 480px) {
      #cgu-content {
        padding: 15px;
        font-size: 14px;
      }
      #cgu-content h2 {
        font-size: 18px;
        margin-top: 5px;
        margin-bottom: 10px;
      }
    }

    #cgu-buttons {
      margin-top: 20px;
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      gap: 10px;
    }

    .cgu-button {
      padding: 10px 20px;
      background-color: #007BFF;
      border: none;
      border-radius: 5px;
      color: white;
      cursor: pointer;
      font-size: 16px;
      transition: background-color 0.3s ease;
      min-width: 120px;
    }

    @media (max-width: 480px) {
      .cgu-button {
        padding: 12px 20px;
        font-size: 16px;
        min-width: 100px;
      }
    }

    .cgu-button:hover {
      background-color: #0056b3;
    }

    /* Overlay d'information pour mobiles */
    #mobile-info {
      position: fixed;
      top: 10px;
      right: 10px;
      background-color: rgba(0, 0, 0, 0.6);
      color: white;
      padding: 10px;
      border-radius: 5px;
      font-size: 14px;
      z-index: 100;
      max-width: 200px;
      display: none;
    }
  </style>
</head>
<body>

<div id="cgu-modal">
  <canvas id="cgu-background"></canvas>
  <div id="cgu-content">
    <h2>Conditions Générales d'Utilisation</h2>
    <p>En accédant à cette animation, vous acceptez les conditions suivantes :<br>
    Il s'agit d'une expérience visuelle générative à titre expérimental.<br>
    Aucune donnée personnelle n'est collectée. Cliquez sur "Accepter" pour continuer.</p>
    <div id="cgu-buttons">
      <button class="cgu-button" onclick="acceptCGU()">Accepter</button>
      <button class="cgu-button" onclick="refuseCGU()">Refuser</button>
    </div>
  </div>
</div>

<div id="mobile-info">
  Touchez les cercles pour les faire disparaître
</div>

<canvas id="canvas" style="display: none;"></canvas>
<audio id="sound" src="2019.mp3" preload="auto"></audio>

<script>
  const canvas = document.getElementById("canvas");
  const ctx = canvas.getContext("2d");

  const cguCanvas = document.getElementById("cgu-background");
  const cguCtx = cguCanvas.getContext("2d");

  const sound = document.getElementById("sound");
  const mobileInfo = document.getElementById("mobile-info");

  // Configuration responsive
  const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  
  // Ajuster la taille des cercles en fonction du dispositif
  const baseRadius = isMobile ? 16 : 22;
  let radius = baseRadius;
  let diameter = radius * 2;

  const colors = ["#00A993", "#E68B4A", "#7A1619", "#362777", "#EB7AAE",
    "#0069AA", "#DC0C15", "#E03A8D", "#FFFFFF", "#2A4899"];

  const gradientMap = {
    "#00A993": "#E68B4A", "#E68B4A": "#7A1619", "#7A1619": "#362777",
    "#362777": "#EB7AAE", "#EB7AAE": "#0069AA", "#0069AA": "#DC0C15",
    "#DC0C15": "#E03A8D", "#E03A8D": "#FFFFFF", "#FFFFFF": "#2A4899",
    "#2A4899": "#00A993"
  };

  let colorGrid = [];
  let specialCircles = [];
  let specialZones = new Set();
  let hiddenCircles = new Set();
  let disappearing = [];
  const specialLinks = ["page1.html", "page2.html", "page3.html", "page4.html"];
  
  let linearGradientZones = new Map();

  function resizeCanvas() {
  const dpr = window.devicePixelRatio || 1; // Récupérer le ratio de pixels de l'appareil
  canvas.width = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;
  canvas.style.width = `${window.innerWidth}px`;
  canvas.style.height = `${window.innerHeight}px`;
  ctx.scale(dpr, dpr); // Adapter le contexte au ratio de pixels

  // Ajuster dynamiquement le rayon en fonction de la taille de l'écran
  if (isMobile) {
    const desiredCirclesWidth = window.innerWidth < 380 ? 12 : 15;
    radius = Math.min(16, Math.floor(window.innerWidth / desiredCirclesWidth / 2));
  } else {
    radius = baseRadius;
  }

  diameter = radius * 2;

  const cols = Math.ceil(canvas.width / diameter / dpr); // Diviser par le ratio pour compenser
  const rows = Math.ceil(canvas.height / diameter / dpr);

  colorGrid = new Array(rows).fill().map(() => new Array(cols).fill(null));

  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const neighbors = getNeighborColors(x, y);
      let chosenColor;

      if (neighbors.length > 0 && Math.random() < 0.8) {
        chosenColor = neighbors[Math.floor(Math.random() * neighbors.length)];
      } else {
        chosenColor = colors[Math.floor(Math.random() * colors.length)];
      }

      colorGrid[y][x] = chosenColor;
    }
  }

  chooseLinearGradientZones();
}

  function getNeighborColors(cx, cy) {
    const neighborColors = [];
    for (let dy = -1; dy <= 0; dy++) {
      for (let dx = -1; dx <= 1; dx++) {
        const nx = cx + dx;
        const ny = cy + dy;
        if (nx >= 0 && ny >= 0 && ny < colorGrid.length && nx < colorGrid[0].length) {
          const color = colorGrid[ny][nx];
          if (color) neighborColors.push(color);
        }
      }
    }
    return neighborColors;
  }

  function getZone(x, y, targetColor) {
    const visited = new Set();
    const queue = [[x, y]];
    const zone = new Set();

    while (queue.length > 0) {
      const [cx, cy] = queue.shift();
      const key = `${cx},${cy}`;
      if (visited.has(key)) continue;
      visited.add(key);

      if (colorGrid[cy]?.[cx] === targetColor) {
        zone.add(key);
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx !== 0 || dy !== 0) {
              queue.push([cx + dx, cy + dy]);
            }
          }
        }
      }
    }

    return zone;
  }

  function chooseLinearGradientZones() {
    linearGradientZones.clear();
    const zonesToConvert = isMobile ? 100 : 200; // Moins de zones sur mobile pour de meilleures performances
    const maxAttempts = 200;
    let attempts = 0;

    while (linearGradientZones.size < zonesToConvert && attempts < maxAttempts) {
      const x = Math.floor(Math.random() * colorGrid[0].length);
      const y = Math.floor(Math.random() * colorGrid.length);
      const color = colorGrid[y][x];
      const zone = getZone(x, y, color);

      if (zone.size > 5) {
        const baseAngle = Math.random() * 2 * Math.PI;
        const phaseOffset = Math.random() * Math.PI * 2;
        
        // Décider du type d'animation pour cette zone (30% de progression linéaire, 70% oscillation)
        const animationType = Math.random() < 0.3 ? 'progression' : 'oscillation';
        
        // Paramètres communs
        const animationSpeed = 0.5 + Math.random() * 1.5;
        
        // Paramètres spécifiques à l'oscillation
        const oscillationAmount = Math.PI / 4 + Math.random() * Math.PI / 4;
        
        let zoneCount = 0;
        for (const key of zone) {
          if (!linearGradientZones.has(key)) {
            linearGradientZones.set(key, {
              baseAngle,
              phaseOffset,
              animationType,
              animationSpeed,
              oscillationAmount
            });
            zoneCount++;
          }
          if (zoneCount > 10 + Math.random() * 20) break;
        }
      }

      attempts++;
    }
  }

  function chooseSpecialCircles() {
    specialCircles = [];
    specialZones.clear();

    const total = colorGrid.length * colorGrid[0].length;
    const selectedIndices = new Set();
    while (selectedIndices.size < 4) {
      const index = Math.floor(Math.random() * total);
      selectedIndices.add(index);
    }

    let count = 0;
    for (let y = 0; y < colorGrid.length; y++) {
      for (let x = 0; x < colorGrid[0].length; x++) {
        const index = y * colorGrid[0].length + x;
        if (selectedIndices.has(index)) {
          specialCircles.push({ x, y, link: specialLinks[count++] });
          const zone = getZone(x, y, colorGrid[y][x]);
          for (const key of zone) {
            specialZones.add(key);
          }
        }
      }
    }
  }

  function optimizeRendering(time) {
    // Sur mobile, limiter le rendu pour économiser la batterie
    if (isMobile && lastRenderTime && time - lastRenderTime < 16) { // ~60fps
      requestAnimationFrame(optimizeRendering);
      return;
    }
    
    lastRenderTime = time;
    animate(time);
    requestAnimationFrame(optimizeRendering);
  }
  
  let lastRenderTime = 0;

  function animate(time) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    const t = time / 1000;

    for (let y = 0; y < colorGrid.length; y++) {
      for (let x = 0; x < colorGrid[0].length; x++) {
        const key = `${x},${y}`;
        const anim = disappearing.find(a => a.x === x && a.y === y);

        if (hiddenCircles.has(key) && !anim) continue;

        const baseColor = colorGrid[y][x];
        let cx = x * diameter + radius;
        let cy = y * diameter + radius;

        let r = radius;
        if (anim) {
          const elapsed = time - anim.start;
          r *= 1 - elapsed / 400;
          if (elapsed > 400) {
            hiddenCircles.add(key);
            disappearing = disappearing.filter(a => a !== anim);
            continue;
          }
        }

        if (specialZones.has(key)) {
          const shake = isMobile ? 1 : 2; // Moins de secousse sur mobile
          cx += (Math.random() - 0.5) * shake;
          cy += (Math.random() - 0.5) * shake;
        }

        const isSpecial = specialCircles.some(c => c.x === x && c.y === y);
        if (isSpecial) {
          const blink = Math.sin(t * 10);
          if (blink <= 0) continue;
          const smallR = r * 0.5;
          ctx.beginPath();
          ctx.arc(cx, cy, smallR, 0, Math.PI * 2);
          ctx.fillStyle = "#FFFFFF";
          ctx.fill();
        } else {
          const endColor = gradientMap[baseColor.toUpperCase()] || baseColor;

          let gradient;
          if (linearGradientZones.has(key)) {
            const gradientInfo = linearGradientZones.get(key);
            const { baseAngle, phaseOffset, animationType, animationSpeed, oscillationAmount } = gradientInfo;
            
            let currentAngle, position;
            
            // Animation différente selon le type d'animation
            if (animationType === 'progression') {
              // Animation de progression linéaire à travers le cercle
              position = ((t * animationSpeed + phaseOffset) % (Math.PI * 2)) / (Math.PI * 2);
              
              // Calculer la position du dégradé qui traverse le cercle
              const offsetX = Math.cos(baseAngle) * r * 2 * (position - 0.5); 
              const offsetY = Math.sin(baseAngle) * r * 2 * (position - 0.5);
              
              // Créer le dégradé qui se déplace à travers le cercle
              gradient = ctx.createLinearGradient(
                cx - Math.cos(baseAngle) * r, 
                cy - Math.sin(baseAngle) * r,
                cx + Math.cos(baseAngle) * r, 
                cy + Math.sin(baseAngle) * r
              );
            } else {
              // Animation d'oscillation (comme dans la version précédente)
              currentAngle = baseAngle + Math.sin(t * animationSpeed + phaseOffset) * oscillationAmount;
              const dx = Math.cos(currentAngle) * r;
              const dy = Math.sin(currentAngle) * r;
              gradient = ctx.createLinearGradient(cx - dx, cy - dy, cx + dx, cy + dy);
            }
          } else {
            const pulse = 0.3 + 0.2 * Math.sin(t + (x + y) / 5);
            gradient = ctx.createRadialGradient(cx, cy, r * pulse, cx, cy, r);
          }

          gradient.addColorStop(0, baseColor);
          gradient.addColorStop(1, endColor);

          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(cx, cy, r, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }
  }

  // Gestionnaire d'événements unifié pour les clics et les touches
  function handleInteraction(e) {
    e.preventDefault(); // Empêcher le zoom ou autres comportements par défaut sur mobile
    
    // Déterminer les coordonnées selon le type d'événement
    const rect = canvas.getBoundingClientRect();
    let mx, my;
    
    if (e.type === "touchstart" || e.type === "touchmove") {
      const touch = e.touches[0] || e.changedTouches[0];
      mx = touch.clientX - rect.left;
      my = touch.clientY - rect.top;
    } else {
      mx = e.clientX - rect.left;
      my = e.clientY - rect.top;
    }

    const col = Math.floor(mx / diameter);
    const row = Math.floor(my / diameter);

    // Vérifier si on a cliqué sur un cercle spécial
    for (const { x, y, link } of specialCircles) {
      const cx = x * diameter + radius;
      const cy = y * diameter + radius;
      const dist = Math.hypot(mx - cx, my - cy);
      if (dist < radius * 0.5) {
        window.location.href = link;
        return;
      }
    }

    const color = colorGrid[row]?.[col];
    if (!color) return;

    const toHide = new Set();
    const visited = new Set();
    const queue = [[col, row]];

    while (queue.length) {
      const [x, y] = queue.shift();
      const key = `${x},${y}`;
      if (visited.has(key)) continue;
      visited.add(key);

      if (colorGrid[y]?.[x] === color && !hiddenCircles.has(key)) {
        toHide.add(key);
        for (let dy = -1; dy <= 1; dy++) {
          for (let dx = -1; dx <= 1; dx++) {
            if (dx !== 0 || dy !== 0) queue.push([x + dx, y + dy]);
          }
        }
      }
    }

    if (toHide.size > 0) {
      // Essayer de jouer le son seulement après une interaction utilisateur
      try {
        sound.currentTime = 0;
        sound.play().catch(err => console.log("Impossible de jouer le son:", err));
      } catch (e) {
        console.log("Erreur audio:", e);
      }
      
      const now = performance.now();
      for (const key of toHide) {
        const [x, y] = key.split(',').map(Number);
        disappearing.push({ x, y, start: now });
      }
    }
  }

  function showMobileInfo() {
    if (isMobile) {
      mobileInfo.style.display = "block";
      setTimeout(() => {
        mobileInfo.style.opacity = "1";
      }, 100);
      
      // Cacher l'info après quelques secondes
      setTimeout(() => {
        mobileInfo.style.opacity = "0";
        setTimeout(() => {
          mobileInfo.style.display = "none";
        }, 500);
      }, 5000);
    }
  }

  function initCguDecor() {
    cguCanvas.width = window.innerWidth;
    cguCanvas.height = window.innerHeight;
    
    // Ajuster l'espacement sur mobile
    const spacing = isMobile ? 40 : 60;
    
    const bounds = document.getElementById("cgu-content").getBoundingClientRect();
    const margin = isMobile ? 30 : 50;
    const startX = bounds.left - margin;
    const endX = bounds.right + margin;
    const startY = bounds.top - margin;
    const endY = bounds.bottom + margin;
    const cguCircles = [];

    for (let y = startY; y < endY; y += spacing) {
      for (let x = startX; x < endX; x += spacing) {
        if (x < bounds.left || x > bounds.right || y < bounds.top || y > bounds.bottom) {
          const baseColor = colors[Math.floor(Math.random() * colors.length)];
          const endColor = gradientMap[baseColor.toUpperCase()] || baseColor;
          cguCircles.push({ 
            x, y, 
            baseColor, 
            endColor, 
            pulseOffset: Math.random() * Math.PI * 2,
            r: isMobile ? radius * 0.8 : radius // Cercles un peu plus petits sur mobile
          });
        }
      }
    }

    function animateCguDecor(time) {
      cguCtx.clearRect(0, 0, cguCanvas.width, cguCanvas.height);
      const t = time / 1000;
      for (const circle of cguCircles) {
        const pulse = 0.3 + 0.2 * Math.sin(t + circle.pulseOffset);
        const gradient = cguCtx.createRadialGradient(
          circle.x, circle.y, circle.r * pulse,
          circle.x, circle.y, circle.r
        );
        gradient.addColorStop(0, circle.baseColor);
        gradient.addColorStop(1, circle.endColor);

        cguCtx.beginPath();
        cguCtx.arc(circle.x, circle.y, circle.r, 0, Math.PI * 2);
        cguCtx.fillStyle = gradient;
        cguCtx.fill();
      }
      requestAnimationFrame(animateCguDecor);
    }

    requestAnimationFrame(animateCguDecor);
  }

  function acceptCGU() {
    document.getElementById("cgu-modal").style.display = "none";
    canvas.style.display = "block";
    
    // Ajouter les gestionnaires d'événements
    if (isMobile) {
      canvas.addEventListener("touchstart", handleInteraction, { passive: false });
      showMobileInfo();
    } else {
      canvas.addEventListener("click", handleInteraction);
    }
    
    window.addEventListener("resize", debounce(resizeCanvas, 250));
    resizeCanvas();
    chooseSpecialCircles();
    requestAnimationFrame(optimizeRendering);
  }

  function refuseCGU() {
    document.getElementById("cgu-content").innerHTML = `
      <h2>Accès refusé</h2>
      <p>Vous devez accepter les conditions pour accéder à l'expérience.</p>
    `;
  }

  // Fonction utilitaire pour limiter les appels de redimensionnement
  function debounce(func, wait) {
    let timeout;
    return function() {
      const context = this;
      const args = arguments;
      clearTimeout(timeout);
      timeout = setTimeout(() => {
        func.apply(context, args);
      }, wait);
    };
  }

  window.addEventListener("load", () => {
    initCguDecor();
    
    // Vérifier si nous sommes sur un appareil à écran tactile et adapter l'interface
    if (isMobile) {
      document.body.classList.add('mobile');
    }
  });

  window.addEventListener("resize", () => {
    if (document.getElementById("cgu-modal").style.display !== "none") {
      initCguDecor();
    }
  });

  // Gestion des problèmes audio sur iOS
  document.addEventListener('touchstart', function() {
    // Créer et détruire un contexte audio pour débloquer l'API Web Audio sur iOS
    const audioContext = new (window.AudioContext || window.webkitAudioContext)();
    audioContext.resume().then(() => {
      audioContext.close();
    });
    
    // Charger le son si possible
    sound.load();
  }, { once: true });
</script>

</body>
</html>
