<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Balle Gyroscope D√©grad√©e</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #111;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #ball {
      position: absolute;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: #0b03fc6e;
      background-size: 150% 150%;
      background-position: center;
      transition: background 0.3s ease;
    }

    #start-btn {
      padding: 1em 2em;
      font-size: 1.2em;
      background: #00ffcc;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      z-index: 2;
    }

    #info {
      position: absolute;
      bottom: 20px;
      color: white;
      font-family: sans-serif;
      font-size: 0.9em;
    }
    
    /* Style pour les cages rectangulaires */
    .cage {
      position: absolute;
      /* Suppression des bordures */
      box-sizing: border-box;
    }
    
    /* Cages du haut */
    .cage-top {
      top: 10px;
      height: 30px;
      width: 30%;
    }
    
    #cage-top-1 {
      left: 15%;
    }
    
    #cage-top-2 {
      right: 15%;
    }
    
    /* Cages du bas */
    .cage-bottom {
      bottom: 10px;
      height: 30px;
      width: 30%;
    }
    
    #cage-bottom-1 {
      left: 15%;
    }
    
    #cage-bottom-2 {
      right: 15%;
    }
    
    /* Cages lat√©rales (3 de chaque c√¥t√©) */
    .cage-left, .cage-right {
      width: 30px;
      height: 15%;
    }
    
    #cage-left-1 {
      left: 10px;
      top: 20%;
    }
    
    #cage-left-2 {
      left: 10px;
      top: 42.5%;
    }
    
    #cage-left-3 {
      left: 10px;
      top: 65%;
    }
    
    #cage-right-1 {
      right: 10px;
      top: 20%;
    }
    
    #cage-right-2 {
      right: 10px;
      top: 42.5%;
    }
    
    #cage-right-3 {
      right: 10px;
      top: 65%;
    }

    /* Styles pour les coins des cages */
    .cage-corner {
      position: absolute;
      background: white;
    }

    /* Coins pour les cages du haut */
    .cage-top .corner-left {
      top: 0;
      left: -10px; /* Positionner √† gauche */
      width: 10px; /* Rectangle vertical */
      height: 180%; /* Allonger la hauteur */
    }
    .cage-top .corner-right {
      top: 0;
      right: -10px; /* Positionner √† droite */
      width: 10px; /* Rectangle vertical */
      height: 180%; /* Allonger la hauteur */
    }

    /* Coins pour les cages du bas */
    .cage-bottom .corner-left {
      bottom: 0;
      left: -10px; /* Positionner √† gauche */
      width: 10px; /* Rectangle vertical */
      height: 180%; /* Allonger la hauteur */
    }
    .cage-bottom .corner-right {
      bottom: 0;
      right: -10px; /* Positionner √† droite */
      width: 10px; /* Rectangle vertical */
      height: 180%; /* Allonger la hauteur */
    }

    /* Coins pour les cages lat√©rales gauche */
    .cage-left .corner-top {
      top: -10px; /* Positionner en haut */
      left: 0;
      width: 180%; /* Allonger la largeur */
      height: 10px; /* Rectangle horizontal */
    }
    .cage-left .corner-bottom {
      bottom: -10px; /* Positionner en bas */
      left: 0;
      width: 180%; /* Allonger la largeur */
      height: 10px; /* Rectangle horizontal */
    }

    /* Coins pour les cages lat√©rales droite */
    .cage-right .corner-top {
      top: -10px; /* Positionner en haut */
      right: 0;
      width: 180%; /* Allonger la largeur */
      height: 10px; /* Rectangle horizontal */
    }
    .cage-right .corner-bottom {
      bottom: -10px; /* Positionner en bas */
      right: 0;
      width: 180%; /* Allonger la largeur */
      height: 10px; /* Rectangle horizontal */
    }

    @keyframes blink {
        from { opacity: 1; }
        to { opacity: 0.3; }
    }

    #timer-display {
        position: absolute;
        top: 20px;
        right: 20px;
        color: white;
        font-size: 24px;
        font-weight: bold;
        font-family: sans-serif;
        z-index: 10;
    }
  </style>
</head>
<body>
  <button id="start-btn">Activer le gyroscope</button>
  <div id="ball"></div>
  <div id="info"></div>
  
  <!-- Ajout des √©l√©ments audio (corrig√© sans espaces dans les noms de fichiers) -->
  <audio id="pointSound" src="SONORE/1point+.mp3" preload="auto"></audio>
  <audio id="backgroundMusic" src="SONORE/ambiancegyro.mp3" loop preload="auto"></audio>
  <audio id="badSound" src="SONORE/mauvais_bip_ambiance_gyro.mp3" preload="auto"></audio>
  
  <!-- Cages rectangulaires -->
  <div id="cage-top-1" class="cage cage-top">
    <div class="cage-corner corner-left"></div>
    <div class="cage-corner corner-right"></div>
  </div>
  <div id="cage-top-2" class="cage cage-top">
    <div class="cage-corner corner-left"></div>
    <div class="cage-corner corner-right"></div>
  </div>
  
  <div id="cage-bottom-1" class="cage cage-bottom">
    <div class="cage-corner corner-left"></div>
    <div class="cage-corner corner-right"></div>
  </div>
  <div id="cage-bottom-2" class="cage cage-bottom">
    <div class="cage-corner corner-left"></div>
    <div class="cage-corner corner-right"></div>
  </div>
  
  <div id="cage-left-1" class="cage cage-left">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>
  <div id="cage-left-2" class="cage cage-left">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>
  <div id="cage-left-3" class="cage cage-left">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>
  
  <div id="cage-right-1" class="cage cage-right">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>
  <div id="cage-right-2" class="cage cage-right">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>
  <div id="cage-right-3" class="cage cage-right">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>

  <div id="timer-display">02:30</div>

  <script>
    const ball = document.getElementById("ball");
    const startBtn = document.getElementById("start-btn");
    const info = document.getElementById("info");
    const pointSound = document.getElementById("pointSound");
    const backgroundMusic = document.getElementById("backgroundMusic");
    const badSound = document.getElementById("badSound");

    // Configuration des sons
    backgroundMusic.volume = 0.5;
    pointSound.volume = 0.8;
    badSound.volume = 0.8;

    // Pr√©charger tous les sons
    pointSound.load();
    backgroundMusic.load();
    badSound.load();

    // Gestionnaire audio centralis√©
    const audioManager = {
      playBackgroundMusic() {
        backgroundMusic.currentTime = 0;
        const playPromise = backgroundMusic.play();
        if (playPromise !== undefined) {
          playPromise.then(() => {
            // Succ√®s
          }).catch(error => {
            setTimeout(() => {
              backgroundMusic.play().catch(() => {});
            }, 1000);
          });
        }
      },
      playPointSound() {
        const sound = pointSound.cloneNode();
        sound.volume = pointSound.volume;
        sound.play().catch(() => {});
      },
      playBadSound() {
        const sound = badSound.cloneNode();
        sound.volume = badSound.volume;
        sound.play().catch(() => {});
      },
      stopBackgroundMusic() {
        backgroundMusic.pause();
        backgroundMusic.currentTime = 0;
      }
    };

    // Bouton de secours pour activer le son
    const soundButton = document.createElement("button");
    soundButton.textContent = "üîä Activer le son";
    soundButton.style.position = "absolute";
    soundButton.style.bottom = "20px";
    soundButton.style.right = "20px";
    soundButton.style.padding = "10px";
    soundButton.style.backgroundColor = "#00ffcc";
    soundButton.style.border = "none";
    soundButton.style.borderRadius = "10px";
    soundButton.style.cursor = "pointer";
    soundButton.style.zIndex = "100";
    soundButton.style.display = "none";
    soundButton.addEventListener("click", () => {
      audioManager.playBackgroundMusic();
      soundButton.style.display = "none";
    });
    document.body.appendChild(soundButton);

    // D√©grad√©s cycliques pr√©d√©finis
    const gradients = [
      ["#00A993", "#E68B4A"],
      ["#E68B4A", "#7A1619"],
      ["#7A1619", "#362777"],
      ["#362777", "#EB7AAE"],
      ["#EB7AAE", "#0069AA"],
      ["#0069AA", "#DC0C15"],
      ["#DC0C15", "#E03A8D"],
      ["#E03A8D", "#FFFFFF"],
      ["#FFFFFF", "#2A4899"],
      ["#2A4899", "#00A993"]
    ];

    // Ajouter ces √©l√©ments au d√©but du script apr√®s la d√©claration des variables existantes
    const scoreDisplay = document.createElement("div");
    scoreDisplay.id = "score-display";
    scoreDisplay.style.position = "absolute";
    scoreDisplay.style.top = "20px";
    scoreDisplay.style.left = "50%";
    scoreDisplay.style.transform = "translateX(-50%)";
    scoreDisplay.style.color = "white";
    scoreDisplay.style.fontSize = "24px";
    scoreDisplay.style.fontWeight = "bold";
    scoreDisplay.style.fontFamily = "sans-serif";
    scoreDisplay.style.zIndex = "10";
    document.body.appendChild(scoreDisplay);

    let score = 0;
    let gameActive = false;
    let timerSeconds = 150; // 2 minutes 30 secondes
    let timerInterval;
    updateScoreDisplay();

    // Fonction pour mettre √† jour l'affichage du score
    function updateScoreDisplay() {
      scoreDisplay.textContent = `Score: ${score}`;
    }

    // Assigner des identifiants uniques √† chaque gradient pour pouvoir les comparer
    const gradientIds = {};
    gradients.forEach((gradient, index) => {
      gradientIds[`${gradient[0]}_${gradient[1]}`] = index;
    });

    // Fonction pour d√©terminer si deux couleurs sont similaires
    function areSimilarColors(color1, color2) {
      const rgb1 = colorToRgb(color1);
      const rgb2 = colorToRgb(color2);
      if (!rgb1 || !rgb2) return false;
      const distance = Math.sqrt(
        Math.pow(rgb1.r - rgb2.r, 2) +
        Math.pow(rgb1.g - rgb2.g, 2) +
        Math.pow(rgb1.b - rgb2.b, 2)
      );
      const tolerance = 30;
      return distance < tolerance;
    }

    // Fonction pour convertir une couleur (hex ou rgb) en valeurs RGB
    function colorToRgb(color) {
      const rgbMatch = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
      if (rgbMatch) {
        return {
          r: parseInt(rgbMatch[1]),
          g: parseInt(rgbMatch[2]),
          b: parseInt(rgbMatch[3])
        };
      }
      const hexMatch = color.match(/#([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})/);
      if (hexMatch) {
        return {
          r: parseInt(hexMatch[1], 16),
          g: parseInt(hexMatch[2], 16),
          b: parseInt(hexMatch[3], 16)
        };
      }
      return null;
    }

    // Appliquer un d√©grad√© diff√©rent √† chaque cage
    function assignUniqueGradients() {
      const cages = document.querySelectorAll('.cage');
      
      // Cr√©er une copie du tableau de gradients pour pouvoir en retirer au fur et √† mesure
      let availableGradients = [...gradients];
      
      // M√©langer le tableau pour une attribution al√©atoire
      availableGradients = shuffleArray(availableGradients);
      
      // Assigner un d√©grad√© unique √† chaque cage
      cages.forEach((cage, index) => {
        if (index < availableGradients.length) {
          const gradient = availableGradients[index];
          cage.style.background = `linear-gradient(135deg, ${gradient[0]}, ${gradient[1]})`;
        }
      });
    }
    
    // Fonction pour m√©langer un tableau (algorithme de Fisher-Yates)
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // Appliquer un d√©grad√© al√©atoire √† la balle
    let currentBallGradientIndex = Math.floor(Math.random() * gradients.length);
    ball.style.background = `linear-gradient(135deg, ${gradients[currentBallGradientIndex][0]}, ${gradients[currentBallGradientIndex][1]})`;

    // Assigner des d√©grad√©s uniques aux cages
    assignUniqueGradients();

    // Met √† jour la couleur des coins selon le d√©grad√© r√©el appliqu√© en CSS
    function updateCornerColors() {
      const cages = document.querySelectorAll('.cage');
      cages.forEach(cage => {
        // R√©cup√©rer le style de fond actuel de la cage
        const computedStyle = window.getComputedStyle(cage);
        const backgroundImage = computedStyle.backgroundImage;
        
        // Extraire les couleurs du gradient
        let colorStart, colorEnd;
        
        // Extraire les couleurs depuis la propri√©t√© backgroundImage
        const colors = backgroundImage.match(/(#[0-9A-Fa-f]{6}|rgb\([^)]+\))/gi);
        if (colors && colors.length >= 2) {
          colorStart = colors[0];
          colorEnd = colors[1];
        } else {
          // Valeurs par d√©faut si on ne peut pas extraire les couleurs
          colorStart = "#FFFFFF";
          colorEnd = "#CCCCCC";
        }

        const corners = cage.querySelectorAll('.cage-corner');
        corners.forEach(corner => {
          // Cages du haut et du bas
          if (cage.classList.contains('cage-top') || cage.classList.contains('cage-bottom')) {
            if (corner.classList.contains('corner-left')) {
              corner.style.background = colorStart;
            }
            if (corner.classList.contains('corner-right')) {
              corner.style.background = colorEnd;
            }
          }
          // Cages de gauche
          else if (cage.classList.contains('cage-left')) {
            if (corner.classList.contains('corner-top')) {
              corner.style.background = colorStart;
            }
            if (corner.classList.contains('corner-bottom')) {
              corner.style.background = colorEnd;
            }
          }
          // Cages de droite
          else if (cage.classList.contains('cage-right')) {
            if (corner.classList.contains('corner-top')) {
              corner.style.background = colorStart;
            }
            if (corner.classList.contains('corner-bottom')) {
              corner.style.background = colorEnd;
            }
          }
        });
      });
    }

    // On doit appeler updateCornerColors APR√àS assignUniqueGradients
    updateCornerColors();

    let posX = window.innerWidth / 2;
    let posY = window.innerHeight / 2;
    let velX = 0;
    let velY = 0;

    const ballSize = 80;
    const friction = 0.98;
    
    // R√©duction IMPORTANTE de la sensibilit√© (avant: 0.15)
    const accelerationFactor = 0.01;
    
    // Variable pour suivre le dernier changement de couleur
    let lastColorChange = 0;
    const colorChangeDelay = 300; // D√©lai minimum entre les changements de couleur (ms)

    function updateBallPosition() {
      posX += velX;
      posY += velY;

      // V√©rifier les collisions avec les bords de l'√©cran
      if (posX <= 0) {
        posX = 0;
        velX *= -0.7;
      } else if (posX >= window.innerWidth - ballSize) {
        posX = window.innerWidth - ballSize;
        velX *= -0.7;
      }

      if (posY <= 0) {
        posY = 0;
        velY *= -0.7;
      } else if (posY >= window.innerHeight - ballSize) {
        posY = window.innerHeight - ballSize;
        velY *= -0.7;
      }
      
      // Collision avec les cages rectangulaires
      checkCageCollisions();

      velX *= friction;
      velY *= friction;

      ball.style.left = posX + "px";
      ball.style.top = posY + "px";

      requestAnimationFrame(updateBallPosition);
    }
    
    function changeBallColor() {
      const now = Date.now();
      // V√©rifier si on peut changer la couleur (pour √©viter les changements trop rapides)
      if (now - lastColorChange >= colorChangeDelay) {
        // Choisir un nouvel index diff√©rent de l'actuel
        let newIndex;
        do {
          newIndex = Math.floor(Math.random() * gradients.length);
        } while (newIndex === currentBallGradientIndex);
        
        currentBallGradientIndex = newIndex;
        ball.style.background = `linear-gradient(135deg, ${gradients[currentBallGradientIndex][0]}, ${gradients[currentBallGradientIndex][1]})`;
        lastColorChange = now;
      }
    }
    
    // Configuration des animations am√©lior√©es - Modifications pour des animations plus dynamiques
    const cageAnimationConfig = {
      minDuration: 2000,  // Dur√©e minimum d'un cycle d'animation r√©duite (avant: 5000)
      maxDuration: 4000,  // Dur√©e maximum d'un cycle d'animation r√©duite (avant: 9000)
      minSize: 0.6,       // Taille minimum plus petite (avant: 0.8)
      maxSize: 1.4,       // Taille maximum plus grande (avant: 1.2)
    };

    // Stocker les dimensions originales des cages
    const cageOriginalDimensions = {};

    // Variable pour suivre l'√©tat des collisions
    const collisionCooldowns = {};

    // Initialiser les animations des cages avec des transitions CSS plus rapides
    function initCageAnimations() {
      const cages = document.querySelectorAll('.cage');
      
      cages.forEach((cage, index) => {
        // Transition plus rapide pour des animations plus dynamiques
        cage.style.transition = "width 0.8s ease-in-out, height 0.8s ease-in-out, top 0.8s ease-in-out";
        
        // Stocker les dimensions originales
        const rect = cage.getBoundingClientRect();
        const style = window.getComputedStyle(cage);
        
        cageOriginalDimensions[cage.id] = {
          width: rect.width,
          height: rect.height,
          left: parseFloat(style.left || "0"),
          top: parseFloat(style.top || "0"),
          right: parseFloat(style.right || "0"),
          bottom: parseFloat(style.bottom || "0")
        };
        
        // Initialiser le cooldown de collision
        collisionCooldowns[cage.id] = 0;
        
        // D√©marrer l'animation avec un d√©lai al√©atoire pour d√©synchroniser
        setTimeout(() => {
          animateCage(cage);
        }, Math.random() * 1000); // D√©lai plus court pour commencer les animations plus rapidement
      });
    }

    // Animation d'une cage individuelle avec easing et variations plus importantes
    function animateCage(cage) {
      const original = cageOriginalDimensions[cage.id];
      
      // D√©terminer si la cage est horizontale ou verticale
      const isHorizontal = cage.classList.contains('cage-top') || cage.classList.contains('cage-bottom');
      const isSideLeft = cage.classList.contains('cage-left');
      const isSideRight = cage.classList.contains('cage-right');
      
      // G√©n√©rer des valeurs al√©atoires pour cette animation
      const duration = Math.random() * 
        (cageAnimationConfig.maxDuration - cageAnimationConfig.minDuration) + 
        cageAnimationConfig.minDuration;
      
      const sizeFactor = Math.random() * 
        (cageAnimationConfig.maxSize - cageAnimationConfig.minSize) + 
        cageAnimationConfig.minSize;
      
      // Appliquer les nouvelles dimensions avec transition CSS
      if (isHorizontal) {
        // Pour les cages horizontales (haut/bas), on anime la largeur
        const newWidth = original.width * sizeFactor;
        cage.style.width = `${newWidth}px`;
        // Ajouter un peu de mouvement horizontal al√©atoire
        if (cage.classList.contains('cage-top-1') || cage.classList.contains('cage-bottom-1')) {
          const newLeft = original.left + (Math.random() * 20 - 10);
          cage.style.left = `${newLeft}px`;
        }
      } else if (isSideLeft || isSideRight) {
        const newHeight = original.height * sizeFactor;
        cage.style.height = `${newHeight}px`;
        // Ajuster la position pour garder le centre √† la m√™me position
        const deltaHeight = newHeight - original.height;
        const newTop = Math.max(0, original.top - (deltaHeight / 2) + (Math.random() * 20 - 10));
        cage.style.top = `${newTop}px`;
      }
      
      // Mettre √† jour les corners apr√®s la transition
      setTimeout(() => {
        updateCageCorners(cage);
      }, 100);
      
      // Planifier la prochaine animation
      setTimeout(() => {
        animateCage(cage);
      }, duration);
    }

    // Fonction pour mettre √† jour les positions des coins en fonction de l'animation des cages
    function updateCageCorners(cage) {
      // Les coins restent positionn√©s en relatif, donc rien √† faire ici pour l'instant
    }

    // Mise √† jour de la fonction de d√©tection de collision avec p√©riode de gr√¢ce
    function checkCageCollisions() {
      const cages = document.querySelectorAll('.cage');
      const ballRadius = ballSize / 2;
      const ballCenterX = posX + ballRadius;
      const ballCenterY = posY + ballRadius;

      const now = Date.now();
      let collisionDetected = false;

      cages.forEach(cage => {
        // V√©rifier si cette cage est en p√©riode de cooldown
        if (collisionCooldowns[cage.id] > now) {
          return; // Ignorer cette cage pendant sa p√©riode de cooldown
        }

        // Utiliser getBoundingClientRect pour obtenir les dimensions et positions actuelles
        const cageRect = cage.getBoundingClientRect();

        // V√©rifier si la balle touche une cage
        if (ballCenterX + ballRadius > cageRect.left &&
            ballCenterX - ballRadius < cageRect.right &&
            ballCenterY + ballRadius > cageRect.top &&
            ballCenterY - ballRadius < cageRect.bottom) {

          collisionDetected = true;

          // D√©terminer de quel c√¥t√© la collision a eu lieu
          const dx = ballCenterX - (cageRect.left + cageRect.width / 2);
          const dy = ballCenterY - (cageRect.top + cageRect.height / 2);

          // Rebond en fonction de la direction de la collision
          if (Math.abs(dx) > Math.abs(dy)) {
            // Collision horizontale
            velX *= -0.7;
            if (dx > 0) {
              // Collision √† gauche
              posX = cageRect.right;
            } else {
              // Collision √† droite
              posX = cageRect.left - ballSize;
            }
          } else {
            // Collision verticale
            velY *= -0.7;
            if (dy > 0) {
              // Collision en haut
              posY = cageRect.bottom;
            } else {
              // Collision en bas
              posY = cageRect.top - ballSize;
            }
          }

          // Comparer le gradient de la balle avec celui de la cage (code existant)
          const computedStyle = window.getComputedStyle(cage);
          const cageGradient = computedStyle.backgroundImage;
          const cageColors = cageGradient.match(/(#[0-9A-Fa-f]{6}|rgb\([^)]+\))/gi);

          const ballStyle = window.getComputedStyle(ball);
          const ballGradient = ballStyle.backgroundImage;
          const ballColors = ballGradient.match(/(#[0-9A-Fa-f]{6}|rgb\([^)]+\))/gi);

          // Cr√©er un effet visuel pour montrer le changement de score
          const scoreEffect = document.createElement("div");
          scoreEffect.style.position = "absolute";
          scoreEffect.style.left = `${ballCenterX}px`;
          scoreEffect.style.top = `${ballCenterY - 30}px`;
          scoreEffect.style.fontFamily = "sans-serif";
          scoreEffect.style.fontSize = "20px";
          scoreEffect.style.fontWeight = "bold";
          scoreEffect.style.zIndex = "20";
          scoreEffect.style.transition = "transform 0.5s, opacity 0.5s";

          // Comparer les gradients en utilisant l'apparence visuelle (similaire)
          if (cageColors && ballColors &&
              areSimilarColors(cageColors[0], ballColors[0]) &&
              areSimilarColors(cageColors[1], ballColors[1])) {
            // M√™me gradient, +1 point
            score += 1;
            scoreEffect.textContent = "+1";
            scoreEffect.style.color = "#00FF00";
            audioManager.playPointSound();
          } else {
            // Gradient diff√©rent, -1 point
            score -= 1;
            scoreEffect.textContent = "-1";
            scoreEffect.style.color = "#FF0000";
            audioManager.playBadSound();
          }

          document.body.appendChild(scoreEffect);

          // Animation de l'effet de score
          setTimeout(() => {
            scoreEffect.style.transform = "translateY(-30px)";
            scoreEffect.style.opacity = "0";
          }, 10);

          // Suppression de l'effet apr√®s l'animation
          setTimeout(() => {
            if (scoreEffect.parentNode) {
              document.body.removeChild(scoreEffect);
            }
          }, 600);

          // Mettre √† jour l'affichage du score
          updateScoreDisplay();

          // Changer la couleur de la balle lors d'une collision
          changeBallColor();

          // Mettre la cage en cooldown pour √©viter les collisions multiples rapides
          collisionCooldowns[cage.id] = now + 400;
        }
      });

      return collisionDetected;
    }

    // Ajouter cette fonction pour actualiser les animations r√©guli√®rement
    function updateAnimations() {
      updateCageCorners();
      requestAnimationFrame(updateAnimations);
    }
    updateAnimations();

    function startGyro() {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(permissionState => {
                    if (permissionState === 'granted') {
                        initGame();
                    } else {
                        info.textContent = "Permission refus√©e ‚ùå";
                    }
                })
                .catch(console.error);
        } else {
            initGame();
        }
    }

    function initGame() {
        enableGyro();
        startBtn.style.display = 'none';
        info.textContent = "Gyroscope activ√© ‚úîÔ∏è";
        gameActive = true;
        timerSeconds = 150;
        score = 0;
        updateScoreDisplay();
        timerDisplay.textContent = "02:30";
        timerDisplay.style.color = "white";
        timerDisplay.style.animation = "none";
        timerInterval = setInterval(updateTimer, 1000);
        initCageAnimations();
        // Utiliser le gestionnaire audio pour d√©marrer la musique
        audioManager.playBackgroundMusic();
        // Afficher le bouton de son apr√®s un court d√©lai si la musique ne d√©marre pas
        setTimeout(() => {
          if (backgroundMusic.paused) {
            soundButton.style.display = "block";
          }
        }, 1000);
    }

    function enableGyro() {
      window.addEventListener("deviceorientation", (event) => {
        const gamma = event.gamma || 0;
        const beta = event.beta || 0;

        velX += gamma * accelerationFactor;
        velY += beta * accelerationFactor;
      });

      updateBallPosition();
    }

    startBtn.addEventListener("click", startGyro);

    // Fonction pour mettre √† jour le timer
    function updateTimer() {
        if (timerSeconds <= 0) {
            endGame();
            return;
        }
        
        timerSeconds--;
        const minutes = Math.floor(timerSeconds / 60);
        const seconds = timerSeconds % 60;
        timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
        
        if (timerSeconds <= 30) {
            timerDisplay.style.color = "#FF0000";
            if (timerSeconds <= 10) {
                timerDisplay.style.animation = "blink 0.5s infinite alternate";
            }
        }
    }

    function endGame() {
        clearInterval(timerInterval);
        gameActive = false;
        audioManager.stopBackgroundMusic();
        alert(`Temps √©coul√©! Score final: ${score}`);
        score = 0;
        updateScoreDisplay();
        timerSeconds = 150;
        timerDisplay.textContent = "02:30";
        timerDisplay.style.color = "white";
        timerDisplay.style.animation = "none";
        startBtn.style.display = 'block';
    }
  </script>
</body>
</html>
