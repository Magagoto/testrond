<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Grille + rectangle central avec CGU</title>
<style>
@font-face {
  font-family: 'AMORIA';
  src: url('AMORIA.otf') format('opentype');
  font-weight: normal;
  font-style: normal;
}
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden !important;
  background: #07114d;
  /* Empêche le scroll sur mobile */
  touch-action: none;
}
body {
  width: 100vw;
  height: 100vh;
  position: relative;
  overflow: hidden !important;
  /* Désactive le scroll */
  overscroll-behavior: none;
}
#canvas {
  position: absolute;
  inset: 0;
  width: 100vw;
  height: 100vh;
  z-index: 0;
  display: block;
}
.center-rect {
  position: absolute;
  left: 50%;
  top: 50%;
  width: 320px;
  height: 320px;
  background: #07114d; /* même couleur que le fond de page */
  border: 2.5px solid #fff;
  box-shadow: 0 8px 32px 0 rgba(0,0,0,0.22), 0 1.5px 16px 0 rgba(62,95,255,0.10);
  border-radius: 22px;
  transform: translate(-50%, -50%);
  z-index: 2;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  padding: 18px 18px 12px 18px;
  box-sizing: border-box;
  font-family: 'Inter', Arial, sans-serif;
  color: #fff;
  overflow: hidden; /* Désactive le scroll dans le CGU */
  backdrop-filter: blur(12px) saturate(1.3);
  transition: box-shadow 0.3s, border 0.3s, background 0.3s;
}

/* Scrollbar stylisée pour le rectangle CGU */
.center-rect::-webkit-scrollbar {
  width: 6px;
  background: transparent;
}
.center-rect::-webkit-scrollbar-thumb {
  background: linear-gradient(135deg, #ff5eae 0%, #ff94d6 100%);
  border-radius: 10px;
  min-height: 28px;
  box-shadow: 0 2px 8px #ff5eae33;
  border: 1.5px solid #fff3;
}
.center-rect::-webkit-scrollbar-thumb:hover {
  background: linear-gradient(135deg, #ff94d6 0%, #ff5eae 100%);
}
.center-rect::-webkit-scrollbar-track {
  background: #07114d;
  border-radius: 10px;
}
.center-rect {
  scrollbar-width: thin;
  scrollbar-color: #ff5eae #07114d;
}

.center-rect h1 {
  font-family: 'AMORIA', serif;
  font-size: 1.3em; /* réduit */
  margin-bottom: 10px;
  margin-top: 2px;
  letter-spacing: 0.08em;
  text-align: center;
  color: #fff;
  text-shadow: 0 2px 12px #0006, 0 1px 0 #fff2;
  font-weight: 700;
  /* plus de chrome, style sobre et élégant */
}

.center-rect h2 {
  font-size: 0.95em; /* réduit */
  margin-top: 10px;
  margin-bottom: 12px;
  font-family: 'Inter', Arial, sans-serif;
  font-weight: 700;
  color: #fff;
  letter-spacing: 0.04em;
  text-shadow: 0 1px 8px #0002;
  border-bottom: 1.5px solid #fff2;
  padding-bottom: 6px;
  width: 100%;
  text-align: center;
}

.center-rect p {
  font-size: 1em;
  text-align: center;
  margin: 12px 0 8px 0;
  line-height: 1.6;
  font-family: 'Inter', Arial, sans-serif;
  color: #e3e8ff;
  text-shadow: 0 1px 8px #0002;
}

#cgu-buttons {
  display: flex;
  gap: 18px;
  margin-top: 20px;
}

.cgu-button {
  background: #fff;
  color: #222b4d;
  border: none;
  border-radius: 7px;
  padding: 10px 26px;
  font-family: 'Inter', Arial, sans-serif;
  font-size: 1em;
  font-weight: 700;
  cursor: pointer;
  box-shadow: 0 2px 8px 0 #0002;
  transition: background 0.2s, box-shadow 0.2s, transform 0.15s, color 0.2s;
  outline: none;
}

.cgu-button:hover, .cgu-button:focus {
  background: #222b4d;
  color: #fff;
  box-shadow: 0 4px 16px 0 #0004;
  transform: translateY(-2px) scale(1.04);
}

@media (max-width: 600px) {
  .center-rect {
    width: 80vw;
    max-width: 90vw;
    height: 70vw;
    max-height: 75vw;
    min-height: 100px;
    padding: 6px 2vw 4px 2vw;
    border-radius: 14px;
    /* Ajout pour remonter le cadre sur mobile */
    top: 48%;
    transform: translate(-50%, -48%);
  }
  .center-rect h1 {
    font-size: 1em;
    margin-bottom: 7px;
  }
  .center-rect h2 {
    font-size: 0.8em;
    margin-top: 4px;
    margin-bottom: 6px;
    padding-bottom: 3px;
  }
  .center-rect p {
    font-size: 0.8em;
    line-height: 1.3;
  }
  .cgu-button {
    font-size: 0.85em;
    padding: 7px 12px;
  }
  #cgu-buttons {
    gap: 8px;
    margin-top: 10px;
  }
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<audio id="backgroundMusic" src="SONORE/ambiance page principale.mp3" loop preload="auto" autoplay></audio>
<div class="center-rect">
  <h1>Chroméa</h1>
  <h2>Conditions Générales d'Utilisation</h2>
  <div style="text-align:left; font-size:0.85em; line-height:1.5; max-height:48vh; overflow:auto; width:100%; box-sizing:border-box;">
    <b>Conditions Générales de Jeu</b><br>
    <br>
    <b>Titre du projet expérientiel :</b> Papaoutai<br>
    <b>Version 1.0 — En vigueur à compter du 05/05/2025</b><br>
    <b>Éditeur :</b> Margot Capello
    <br><br>
    <b>Préambule</b><br>
    Les présentes Conditions Générales de Jeu (ci-après les « CGJ ») régissent, dans le respect des dispositions légales en vigueur, les modalités d’accès, d’utilisation, d’interaction et de participation volontaire, consciente ou partiellement engagée au sein du système interactif multimodal (ci-après désigné « le Jeu »), déployé via interface numérique connectée, combinée à des déplacements physiques réels dans un périmètre géographique déterminé (Orléans, France métropolitaine), dans le cadre d’une expérience hybride relevant de la fiction ludique à activation géolocalisée.<br>
    <br>
    Le fait d’accéder, même de manière passive, occasionnelle ou involontaire, à tout ou partie du Jeu, vaut acceptation pleine, entière, irrévocable et sans condition des présentes CGJ, ce quelles que soient les modalités techniques de consultation, les niveaux de compréhension du Joueur, ou les intentions initiales, implicites, présumées ou rétroactives.
    <br><br>
    <b>Article 1 – Objet</b><br>
    Le Jeu a pour finalité de proposer une expérience de type fiction interactive, combinant une interface web géo-sensible avec une série d’actions, de déplacements, d’actes de raffinement, d’extractions énergétiques symboliques et/ou métaphoriques, en lien avec des points de coordonnées précises situés dans l’espace public ou assimilé, sous la forme d’une narration fragmentaire, non linéaire, potentiellement évolutive, à caractère immersif et subjectif. Le Joueur y est invité à interagir selon des modalités spécifiques dictées par l’interface, dans un cadre immersif où les limites entre la fiction, le réel, le gameplay et la dérive urbaine ne sont pas explicitement définies, ni garanties.
    <br><br>
    <b>Article 2 – Accès et compatibilité technique</b><br>
    L’accès au Jeu est subordonné à l’utilisation d’un terminal mobile personnel, connecté à un réseau internet fonctionnel, équipé d’un navigateur compatible avec les technologies récentes (HTML5, JavaScript activé, prise en charge du protocole TLS), disposant d’un système de géolocalisation GPS activé et autorisé. Il est rappelé que l’utilisation du Jeu peut nécessiter une stabilité de connexion, une autonomie énergétique suffisante du terminal utilisé, ainsi qu’un niveau d’attention et de mobilité compatibles avec la navigation dans un espace public urbain non sécurisé par l’Éditeur.<br>
    <br>
    L’Éditeur décline toute responsabilité en cas d’incompatibilité logicielle ou matérielle, d’interruption de service, de perte de données, de fatigue cognitive ou de désorientation induite par l’usage ou la mauvaise interprétation des instructions diffusées via l’interface.
    <br><br>
    <b>Article 3 – Inscription, identification, anonymat</b><br>
    Aucun processus d’identification nominative n’est requis à l’accès initial du Jeu. Toutefois, certaines fonctionnalités peuvent solliciter, sans obligation, la saisie d’un identifiant, pseudonyme ou désignation symbolique nécessaire à la personnalisation de l’expérience. Le Joueur reconnaît que son anonymat n’exclut pas la collecte ponctuelle, temporaire, volatile ou non persistante de données non identifiantes mais à potentiel analytique ou comportemental.
    <br><br>
    <b>Article 4 – Fonctionnement, interaction, raffinement</b><br>
    Le Joueur sera conduit, par l’intermédiaire de stimuli visuels, cartographiques, textuels ou intuitifs, à se rendre physiquement dans des lieux déterminés, définis par des coordonnées géographiques spécifiques, lesquelles peuvent faire l’objet de mises à jour sans notification préalable. Une fois sur place, et sous réserve du bon fonctionnement des outils de géolocalisation, le Joueur pourra initier un processus de raffinement énergétique fictif, sans incidence matérielle directe, mais intégré dans une logique d’accumulation, d’évolution ou de transformation symbolique au sein de l’univers du Jeu.<br>
    <br>
    Il est expressément précisé que l’interface peut répondre de manière non linéaire, non déterministe ou aléatoire aux actions du Joueur, sans garantie de reconnaissance immédiate ou de retour fonctionnel identifiable.
    <br><br>
    <b>Article 5 – Obligations et comportement du Joueur</b><br>
    Le Joueur s’engage à :
    <ul style="margin-top:0;margin-bottom:0.5em;">
      <li>respecter les règles de circulation, d’accès et de sécurité dans les espaces publics ou privés ;</li>
      <li>ne pas causer de perturbation, nuisance, danger ou intrusion au nom de l’expérience ludique ;</li>
      <li>agir de manière autonome, responsable et respectueuse des tiers et de l’environnement ;</li>
      <li>ne pas interpréter littéralement toute instruction de l’interface sans esprit critique ou discernement personnel.</li>
    </ul>
    L’Éditeur ne saurait être tenu responsable de tout acte ou comportement inapproprié, délictueux, accidentel ou interprétatif résultant de l’interaction du Joueur avec les contenus du Jeu, ni des conséquences physiques, mentales, sociales ou philosophiques de l’expérience vécue.
    <br><br>
    <b>Article 6 – Données, collecte, traitement</b><br>
    Dans le cadre strict de son fonctionnement, le Jeu peut accéder, de manière ponctuelle et temporaire, à des données de géolocalisation, à des horodatages de déplacement, à des interactions cliquées ou déclenchées par le Joueur, à des séquences de raffinement activées ou non activées, à des données techniques d’usage (modèle de terminal, navigateur, version logicielle, etc.).<br>
    <br>
    Ces données sont utilisées exclusivement aux fins de bon fonctionnement, de calibration narrative, de validation d’étapes internes ou d’amélioration future du dispositif. Aucune donnée n’est revendable à des tiers, sauf en cas de dissolution ou revente hypothétique de l’ensemble du système, auquel cas un processus d’anonymisation partielle ou différée pourra être envisagé sous réserve de faisabilité technique et/ou éthique.
    <br><br>
    <b>Article 7 – Modification des conditions</b><br>
    L’Éditeur se réserve le droit, à tout moment, sans justification ni obligation de notification préalable, de modifier, adapter, suspendre, restreindre, remplacer ou annuler tout ou partie des présentes CGJ, ou toute fonctionnalité, règle, interface ou logique narrative du Jeu, sans que le Joueur puisse prétendre à une quelconque indemnité, compensation, alerte ou retour d’expérience obligatoire.
    <br><br>
    <b>Article 8 – Durée, fin d’expérience et résidu fictionnel</b><br>
    La participation au Jeu est libre, sans durée minimale ou maximale garantie. Le Joueur peut cesser sa participation à tout moment, en interrompant ses interactions avec l’interface. Toutefois, il est admis que certains effets secondaires symboliques, psychogéographiques, émotionnels ou interprétatifs puissent se maintenir après la fin de l’usage actif du Jeu, sans que l’Éditeur puisse en être tenu responsable.
    <br><br>
    <b>Article 9 – Droit applicable et clause d’arbitrage existentiel</b><br>
    Les présentes CGJ sont régies par le droit français. Tout litige, malentendu, crise existentielle ou déni de réalité résultant de l’interprétation du Jeu, des actions entreprises ou non entreprises par le Joueur, ou de la friction entre les attentes et la proposition ludique, sera tranché par un tribunal intérieur imaginaire, dans une salle d’audience mentale où comparaîtront en silence l’intuition, le doute et le déplacement.
  </div>
  <div id="cgu-buttons">
    <button class="cgu-button" onclick="acceptCGU()">Accepter</button>
    <button class="cgu-button" onclick="refuseCGU()">Refuser</button>
  </div>
</div>
<!-- Vérification : il n'y a qu'un seul rectangle central (center-rect) affiché.
Aucun autre rectangle ou div superposée n'est présent dans le HTML. 
Si tu vois un rectangle en dessous, il s'agit probablement d'un effet visuel du canvas ou du CSS (ombre portée, etc.).
Aucune modification n'est nécessaire pour supprimer un rectangle supplémentaire, car il n'y en a pas dans le code. -->

<script>
// Fonction pour gérer l'acceptation des CGU
function acceptCGU() {
  window.location.href = "jeu.html";
  // Pour lancer la musique sur la page CGU si besoin :
  // document.getElementById('backgroundMusic').play();
}

// Fonction pour gérer le refus des CGU
function refuseCGU() {
  alert("Vous devez accepter les CGU pour accéder à l'expérience.");
}

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
// Configuration responsive
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
// Ajuster la taille des cercles en fonction du dispositif
const baseRadius = isMobile ? 16 : 22; // Agrandir les ronds
let radius = baseRadius;
let diameter = radius * 2;
const colors = ["#00A993", "#E68B4A", "#7A1619", "#362777", "#EB7AAE",
"#0069AA", "#DC0C15", "#E03A8D", "#FFFFFF", "#2A4899"];
const gradientMap = {
  "#00A993": "#E68B4A", "#E68B4A": "#7A1619", "#7A1619": "#362777",
  "#362777": "#EB7AAE", "#EB7AAE": "#0069AA", "#0069AA": "#DC0C15",
  "#DC0C15": "#E03A8D", "#E03A8D": "#FFFFFF", "#FFFFFF": "#2A4899",
  "#2A4899": "#00A993"
};
let colorGrid = [];
let appearingZones = []; // Liste des zones de cercles à afficher progressivement
let currentZoneIndexTop = 0;
let currentZoneIndexBottom = 0;
let currentCircleIndexTop = 0;
let currentCircleIndexBottom = 0;

// --- Ajout pour les dégradés linéaires animés ---
let linearGradientZones = new Map();

function chooseLinearGradientZones() {
  linearGradientZones.clear();
  // 1 zone sur 3 en dégradé linéaire animé
  let zoneIndex = 0;
  const totalZones = appearingZones.length;
  for (let i = 0; i < totalZones; i++) {
    if (i % 3 === 0) {
      const zone = appearingZones[i];
      if (!zone || zone.length < 2) continue;
      const baseAngle = Math.random() * 2 * Math.PI;
      const phaseOffset = Math.random() * Math.PI * 2;
      const animationSpeed = 0.5 + Math.random() * 1.5;
      const oscillationAmount = Math.PI / 4 + Math.random() * Math.PI / 4;
      for (const {x, y} of zone) {
        const key = `${x},${y}`;
        linearGradientZones.set(key, {
          baseAngle,
          phaseOffset,
          animationSpeed,
          oscillationAmount
        });
      }
    }
  }
}

function resizeCanvas() {
  const dpr = window.devicePixelRatio || 1; // Récupérer le ratio de pixels de l'appareil
  canvas.width = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;
  canvas.style.width = `${window.innerWidth}px`;
  canvas.style.height = `${window.innerHeight}px`;
  ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform avant scale
  ctx.scale(dpr, dpr); // Adapter le contexte au ratio de pixels

  // Ajuster dynamiquement le rayon en fonction de la taille de l'écran
  if (isMobile) {
    const desiredCirclesWidth = window.innerWidth < 380 ? 12 : 15;
    radius = Math.min(16, Math.floor(window.innerWidth / desiredCirclesWidth / 2));
  } else {
    radius = baseRadius;
  }
  diameter = radius * 2;

  // Utiliser un pas de radius pour coller les cercles
  const cols = Math.ceil(window.innerWidth / radius) + 2;
  const rows = Math.ceil(window.innerHeight / radius) + 2;

  colorGrid = new Array(rows).fill().map(() => new Array(cols).fill(null));
  appearingZones = []; // Réinitialiser la liste des zones
  currentZoneIndexTop = 0;
  currentZoneIndexBottom = 0;
  currentCircleIndexTop = 0;
  currentCircleIndexBottom = 0;

  // Générer la grille et regrouper les cercles par zones de couleur
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const neighbors = getNeighborColors(x, y);
      let chosenColor;

      if (neighbors.length > 0 && Math.random() < 0.8) {
        chosenColor = neighbors[Math.floor(Math.random() * neighbors.length)];
      } else {
        chosenColor = colors[Math.floor(Math.random() * colors.length)];
      }

      colorGrid[y][x] = chosenColor;
    }
  }

  // Identifier les zones de couleur
  const visited = new Set();
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const color = colorGrid[y][x];
      if (color && !visited.has(`${x},${y}`)) {
        const zone = getZone(x, y, color, visited);
        appearingZones.push(zone);
      }
    }
  }

  chooseLinearGradientZones(); // Ajout ici
}

function getNeighborColors(cx, cy) {
  const neighborColors = [];
  for (let dy = -1; dy <= 0; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      const nx = cx + dx;
      const ny = cy + dy;
      if (nx >= 0 && ny >= 0 && ny < colorGrid.length && nx < colorGrid[0].length) {
        const color = colorGrid[ny][nx];
        if (color) neighborColors.push(color);
      }
    }
  }
  return neighborColors;
}

function getZone(x, y, targetColor, visited) {
  const queue = [[x, y]];
  const zone = [];

  while (queue.length > 0) {
    const [cx, cy] = queue.shift();
    const key = `${cx},${cy}`;
    if (visited.has(key)) continue;
    visited.add(key);

    if (colorGrid[cy]?.[cx] === targetColor) {
      zone.push({ x: cx, y: cy, color: targetColor });
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx !== 0 || dy !== 0) {
            queue.push([cx + dx, cy + dy]);
          }
        }
      }
    }
  }

  return zone;
}

function isInCenterRect(cx, cy) {
  // Désactivé : autorise les ronds à passer sous le GPU
  return false;
}

function animate(time) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Afficher toutes les zones déjà générées depuis le haut
  for (let i = 0; i < currentZoneIndexTop; i++) {
    const zone = appearingZones[i];
    for (const { x, y, color } of zone) {
      const cx = x * radius;
      const cy = y * radius;
      if (isInCenterRect(cx, cy)) continue;
      // --- Ajout : dégradé linéaire animé pour certaines zones ---
      const key = `${x},${y}`;
      let fillStyle;
      if (linearGradientZones.has(key)) {
        const info = linearGradientZones.get(key);
        const t = (performance.now() / 1000) * info.animationSpeed + info.phaseOffset;
        const angle = info.baseAngle + Math.sin(t) * info.oscillationAmount;
        const dx = Math.cos(angle) * radius;
        const dy = Math.sin(angle) * radius;
        const grad = ctx.createLinearGradient(cx - dx, cy - dy, cx + dx, cy + dy);
        grad.addColorStop(0, color);
        grad.addColorStop(1, gradientMap[color.toUpperCase()] || color);
        fillStyle = grad;
      } else {
        const grad = ctx.createRadialGradient(cx, cy, radius * 0.3, cx, cy, radius);
        grad.addColorStop(0, color);
        grad.addColorStop(1, gradientMap[color.toUpperCase()] || color);
        fillStyle = grad;
      }
      ctx.fillStyle = fillStyle;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  // Afficher toutes les zones déjà générées depuis le bas
  for (let i = 0; i < currentZoneIndexBottom; i++) {
    const zone = appearingZones[appearingZones.length - 1 - i];
    for (const { x, y, color } of zone) {
      const cx = x * radius;
      const cy = y * radius;
      if (isInCenterRect(cx, cy)) continue;
      const key = `${x},${y}`;
      let fillStyle;
      if (linearGradientZones.has(key)) {
        const info = linearGradientZones.get(key);
        const t = (performance.now() / 1000) * info.animationSpeed + info.phaseOffset;
        const angle = info.baseAngle + Math.sin(t) * info.oscillationAmount;
        const dx = Math.cos(angle) * radius;
        const dy = Math.sin(angle) * radius;
        const grad = ctx.createLinearGradient(cx - dx, cy - dy, cx + dx, cy + dy);
        grad.addColorStop(0, color);
        grad.addColorStop(1, gradientMap[color.toUpperCase()] || color);
        fillStyle = grad;
      } else {
        const grad = ctx.createRadialGradient(cx, cy, radius * 0.3, cx, cy, radius);
        grad.addColorStop(0, color);
        grad.addColorStop(1, gradientMap[color.toUpperCase()] || color);
        fillStyle = grad;
      }
      ctx.fillStyle = fillStyle;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  if (currentZoneIndexTop + currentZoneIndexBottom < appearingZones.length) {
    if (currentZoneIndexTop + currentZoneIndexBottom < appearingZones.length) {
      // Zone du haut
      if (currentZoneIndexTop + currentZoneIndexBottom < appearingZones.length) {
        const zoneTop = appearingZones[currentZoneIndexTop];
        for (let j = 0; j <= currentCircleIndexTop; j++) {
          if (j >= zoneTop.length) break;
          const { x, y, color } = zoneTop[j];
          const cx = x * radius;
          const cy = y * radius;
          if (isInCenterRect(cx, cy)) continue;
          const gradient = ctx.createRadialGradient(cx, cy, radius * 0.3, cx, cy, radius);
          gradient.addColorStop(0, color);
          gradient.addColorStop(1, gradientMap[color.toUpperCase()] || color);
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(cx, cy, radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      // Zone du bas
      if (currentZoneIndexTop + currentZoneIndexBottom < appearingZones.length &&
          appearingZones.length - 1 - currentZoneIndexBottom !== currentZoneIndexTop) {
        const zoneBottom = appearingZones[appearingZones.length - 1 - currentZoneIndexBottom];
        for (let j = 0; j <= currentCircleIndexBottom; j++) {
          if (j >= zoneBottom.length) break;
          const { x, y, color } = zoneBottom[j];
          const cx = x * radius;
          const cy = y * radius;
          if (isInCenterRect(cx, cy)) continue;
          const gradient = ctx.createRadialGradient(cx, cy, radius * 0.3, cx, cy, radius);
          gradient.addColorStop(0, color);
          gradient.addColorStop(1, gradientMap[color.toUpperCase()] || color);
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(cx, cy, radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    // Animation des cercles pour chaque zone (plus rapide : +5 à chaque frame)
    let needNextFrame = false;
    const step = 5; // accélération ici
    if (currentZoneIndexTop + currentZoneIndexBottom < appearingZones.length) {
      const zoneTop = appearingZones[currentZoneIndexTop];
      if (currentCircleIndexTop < zoneTop.length - 1) {
        currentCircleIndexTop += step;
        if (currentCircleIndexTop > zoneTop.length - 1) currentCircleIndexTop = zoneTop.length - 1;
        needNextFrame = true;
      } else if (currentZoneIndexTop + currentZoneIndexBottom < appearingZones.length) {
        currentZoneIndexTop++;
        currentCircleIndexTop = 0;
        needNextFrame = true;
      }
      // Zone du bas
      if (appearingZones.length - 1 - currentZoneIndexBottom !== currentZoneIndexTop) {
        const zoneBottom = appearingZones[appearingZones.length - 1 - currentZoneIndexBottom];
        if (currentCircleIndexBottom < zoneBottom.length - 1) {
          currentCircleIndexBottom += step;
          if (currentCircleIndexBottom > zoneBottom.length - 1) currentCircleIndexBottom = zoneBottom.length - 1;
          needNextFrame = true;
        } else if (currentZoneIndexTop + currentZoneIndexBottom < appearingZones.length) {
          currentZoneIndexBottom++;
          currentCircleIndexBottom = 0;
          needNextFrame = true;
        }
      }
    }
    if (needNextFrame) {
      requestAnimationFrame(animate);
    }
  }
}

// Fonction utilitaire pour limiter les appels de redimensionnement
function debounce(func, wait) {
  let timeout;
  return function() {
    const context = this;
    const args = arguments;
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      func.apply(context, args);
    }, wait);
  };
}

// Essaye de jouer la musique dès que possible
document.getElementById('backgroundMusic').play().catch(() => {});

// Initialisation
window.addEventListener("load", () => {
  window.addEventListener("resize", debounce(resizeCanvas, 250));
  resizeCanvas();
  requestAnimationFrame(animate);
});
</script>
</body>
</html>