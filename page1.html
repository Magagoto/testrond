<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Balle Gyroscope Dégradée</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      background: #111;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #ball {
      position: absolute;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: #00ffcc;
      background-size: 150% 150%;
      background-position: center;
      transition: background 0.3s ease;
    }

    #start-btn {
      padding: 1em 2em;
      font-size: 1.2em;
      background: #00ffcc;
      border: none;
      border-radius: 10px;
      cursor: pointer;
      z-index: 2;
    }

    #info {
      position: absolute;
      bottom: 20px;
      color: white;
      font-family: sans-serif;
      font-size: 0.9em;
    }
    
    /* Style pour les cages rectangulaires */
    .cage {
      position: absolute;
      /* Suppression des bordures */
      box-sizing: border-box;
    }
    
    /* Cages du haut */
    .cage-top {
      top: 10px;
      height: 30px;
      width: 30%;
    }
    
    #cage-top-1 {
      left: 15%;
    }
    
    #cage-top-2 {
      right: 15%;
    }
    
    /* Cages du bas */
    .cage-bottom {
      bottom: 10px;
      height: 30px;
      width: 30%;
    }
    
    #cage-bottom-1 {
      left: 15%;
    }
    
    #cage-bottom-2 {
      right: 15%;
    }
    
    /* Cages latérales (3 de chaque côté) */
    .cage-left, .cage-right {
      width: 30px;
      height: 15%;
    }
    
    #cage-left-1 {
      left: 10px;
      top: 20%;
    }
    
    #cage-left-2 {
      left: 10px;
      top: 42.5%;
    }
    
    #cage-left-3 {
      left: 10px;
      top: 65%;
    }
    
    #cage-right-1 {
      right: 10px;
      top: 20%;
    }
    
    #cage-right-2 {
      right: 10px;
      top: 42.5%;
    }
    
    #cage-right-3 {
      right: 10px;
      top: 65%;
    }

    /* Styles pour les coins des cages */
    .cage-corner {
      position: absolute;
      background: white;
    }

    /* Coins pour les cages du haut */
    .cage-top .corner-left {
      top: 0;
      left: -10px; /* Positionner à gauche */
      width: 10px; /* Rectangle vertical */
      height: 180%; /* Allonger la hauteur */
    }
    .cage-top .corner-right {
      top: 0;
      right: -10px; /* Positionner à droite */
      width: 10px; /* Rectangle vertical */
      height: 180%; /* Allonger la hauteur */
    }

    /* Coins pour les cages du bas */
    .cage-bottom .corner-left {
      bottom: 0;
      left: -10px; /* Positionner à gauche */
      width: 10px; /* Rectangle vertical */
      height: 180%; /* Allonger la hauteur */
    }
    .cage-bottom .corner-right {
      bottom: 0;
      right: -10px; /* Positionner à droite */
      width: 10px; /* Rectangle vertical */
      height: 180%; /* Allonger la hauteur */
    }

    /* Coins pour les cages latérales gauche */
    .cage-left .corner-top {
      top: -10px; /* Positionner en haut */
      left: 0;
      width: 180%; /* Allonger la largeur */
      height: 10px; /* Rectangle horizontal */
    }
    .cage-left .corner-bottom {
      bottom: -10px; /* Positionner en bas */
      left: 0;
      width: 180%; /* Allonger la largeur */
      height: 10px; /* Rectangle horizontal */
    }

    /* Coins pour les cages latérales droite */
    .cage-right .corner-top {
      top: -10px; /* Positionner en haut */
      right: 0;
      width: 180%; /* Allonger la largeur */
      height: 10px; /* Rectangle horizontal */
    }
    .cage-right .corner-bottom {
      bottom: -10px; /* Positionner en bas */
      right: 0;
      width: 180%; /* Allonger la largeur */
      height: 10px; /* Rectangle horizontal */
    }
  </style>
</head>
<body>
  <button id="start-btn">Activer le gyroscope</button>
  <div id="ball"></div>
  <div id="info"></div>
  
  <!-- Cages rectangulaires -->
  <div id="cage-top-1" class="cage cage-top">
    <div class="cage-corner corner-left"></div>
    <div class="cage-corner corner-right"></div>
  </div>
  <div id="cage-top-2" class="cage cage-top">
    <div class="cage-corner corner-left"></div>
    <div class="cage-corner corner-right"></div>
  </div>
  
  <div id="cage-bottom-1" class="cage cage-bottom">
    <div class="cage-corner corner-left"></div>
    <div class="cage-corner corner-right"></div>
  </div>
  <div id="cage-bottom-2" class="cage cage-bottom">
    <div class="cage-corner corner-left"></div>
    <div class="cage-corner corner-right"></div>
  </div>
  
  <div id="cage-left-1" class="cage cage-left">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>
  <div id="cage-left-2" class="cage cage-left">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>
  <div id="cage-left-3" class="cage cage-left">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>
  
  <div id="cage-right-1" class="cage cage-right">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>
  <div id="cage-right-2" class="cage cage-right">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>
  <div id="cage-right-3" class="cage cage-right">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>

  <script>
    const ball = document.getElementById("ball");
    const startBtn = document.getElementById("start-btn");
    const info = document.getElementById("info");

    // Dégradés cycliques prédéfinis
    const gradients = [
      ["#00A993", "#E68B4A"],
      ["#E68B4A", "#7A1619"],
      ["#7A1619", "#362777"],
      ["#362777", "#EB7AAE"],
      ["#EB7AAE", "#0069AA"],
      ["#0069AA", "#DC0C15"],
      ["#DC0C15", "#E03A8D"],
      ["#E03A8D", "#FFFFFF"],
      ["#FFFFFF", "#2A4899"],
      ["#2A4899", "#00A993"]
    ];

    // Appliquer un dégradé différent à chaque cage
    function assignUniqueGradients() {
      const cages = document.querySelectorAll('.cage');
      
      // Créer une copie du tableau de gradients pour pouvoir en retirer au fur et à mesure
      let availableGradients = [...gradients];
      
      // Mélanger le tableau pour une attribution aléatoire
      availableGradients = shuffleArray(availableGradients);
      
      // Assigner un dégradé unique à chaque cage
      cages.forEach((cage, index) => {
        if (index < availableGradients.length) {
          const gradient = availableGradients[index];
          cage.style.background = `linear-gradient(135deg, ${gradient[0]}, ${gradient[1]})`;
        }
      });
    }
    
    // Fonction pour mélanger un tableau (algorithme de Fisher-Yates)
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // Appliquer un dégradé aléatoire à la balle
    let currentBallGradientIndex = Math.floor(Math.random() * gradients.length);
    ball.style.background = `linear-gradient(135deg, ${gradients[currentBallGradientIndex][0]}, ${gradients[currentBallGradientIndex][1]})`;

    // Assigner des dégradés uniques aux cages
    assignUniqueGradients();

    let posX = window.innerWidth / 2;
    let posY = window.innerHeight / 2;
    let velX = 0;
    let velY = 0;

    const ballSize = 80;
    const friction = 0.98;
    
    // Réduction de la sensibilité
    const accelerationFactor = 0.15;
    
    // Variable pour suivre le dernier changement de couleur
    let lastColorChange = 0;
    const colorChangeDelay = 300; // Délai minimum entre les changements de couleur (ms)

    function updateBallPosition() {
      posX += velX;
      posY += velY;

      // Vérifier les collisions avec les bords de l'écran
      if (posX <= 0) {
        posX = 0;
        velX *= -0.7;
      } else if (posX >= window.innerWidth - ballSize) {
        posX = window.innerWidth - ballSize;
        velX *= -0.7;
      }

      if (posY <= 0) {
        posY = 0;
        velY *= -0.7;
      } else if (posY >= window.innerHeight - ballSize) {
        posY = window.innerHeight - ballSize;
        velY *= -0.7;
      }
      
      // Collision avec les cages rectangulaires
      checkCageCollisions();

      velX *= friction;
      velY *= friction;

      ball.style.left = posX + "px";
      ball.style.top = posY + "px";

      requestAnimationFrame(updateBallPosition);
    }
    
    function changeBallColor() {
      const now = Date.now();
      // Vérifier si on peut changer la couleur (pour éviter les changements trop rapides)
      if (now - lastColorChange >= colorChangeDelay) {
        // Choisir un nouvel index différent de l'actuel
        let newIndex;
        do {
          newIndex = Math.floor(Math.random() * gradients.length);
        } while (newIndex === currentBallGradientIndex);
        
        currentBallGradientIndex = newIndex;
        ball.style.background = `linear-gradient(135deg, ${gradients[currentBallGradientIndex][0]}, ${gradients[currentBallGradientIndex][1]})`;
        lastColorChange = now;
      }
    }
    
    function checkCageCollisions() {
      const cages = document.querySelectorAll('.cage');
      const ballRadius = ballSize / 2;
      const ballCenterX = posX + ballRadius;
      const ballCenterY = posY + ballRadius;
      
      cages.forEach(cage => {
        const cageRect = cage.getBoundingClientRect();
        
        // Vérifier si la balle touche une cage
        if (ballCenterX + ballRadius > cageRect.left &&
            ballCenterX - ballRadius < cageRect.right &&
            ballCenterY + ballRadius > cageRect.top &&
            ballCenterY - ballRadius < cageRect.bottom) {
          
          // Déterminer de quel côté la collision a eu lieu
          const dx = ballCenterX - (cageRect.left + cageRect.width / 2);
          const dy = ballCenterY - (cageRect.top + cageRect.height / 2);
          
          // Rebond en fonction de la direction de la collision
          if (Math.abs(dx) > Math.abs(dy)) {
            // Collision horizontale
            velX *= -0.7;
            if (dx > 0) {
              // Collision à gauche
              posX = cageRect.right;
            } else {
              // Collision à droite
              posX = cageRect.left - ballSize;
            }
          } else {
            // Collision verticale
            velY *= -0.7;
            if (dy > 0) {
              // Collision en haut
              posY = cageRect.bottom;
            } else {
              // Collision en bas
              posY = cageRect.top - ballSize;
            }
          }
          
          // Changer la couleur de la balle lors d'une collision
          changeBallColor();
        }
      });
    }

    function startGyro() {
      if (typeof DeviceOrientationEvent.requestPermission === 'function') {
        DeviceOrientationEvent.requestPermission()
          .then(permissionState => {
            if (permissionState === 'granted') {
              enableGyro();
              startBtn.style.display = 'none';
              info.textContent = "Gyroscope activé ✔️";
            } else {
              info.textContent = "Permission refusée ❌";
            }
          })
          .catch(console.error);
      } else {
        enableGyro();
        startBtn.style.display = 'none';
        info.textContent = "Gyroscope activé ✔️";
      }
    }

    function enableGyro() {
      window.addEventListener("deviceorientation", (event) => {
        const gamma = event.gamma || 0;
        const beta = event.beta || 0;

        velX += gamma * accelerationFactor;
        velY += beta * accelerationFactor;
      });

      updateBallPosition();
    }

    startBtn.addEventListener("click", startGyro);
  </script>
</body>
</html>
