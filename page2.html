<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D√©tecteur de Marche Am√©lior√©</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            background-color: #f5f5f5;
            transition: background-color 0.8s ease;
        }
        
        .container {
            text-align: center;
            padding: 20px;
            border-radius: 12px;
            background-color: white;
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
            width: 90%;
            max-width: 500px;
        }
        
        h1 {
            color: #333;
            margin-bottom: 20px;
        }
        
        #status {
            font-size: 28px;
            margin: 20px 0;
            font-weight: bold;
            transition: color 0.5s ease;
        }
        
        #icon {
            font-size: 72px;
            margin: 20px 0;
            transition: transform 0.5s ease;
        }
        
        .walking #icon {
            animation: bounce 0.7s infinite alternate;
        }
        
        @keyframes bounce {
            from { transform: translateY(0px); }
            to { transform: translateY(-10px); }
        }
        
        #stats {
            margin: 20px 0;
            text-align: left;
            padding: 15px;
            background-color: #f9f9f9;
            border-radius: 8px;
        }
        
        #sensitivity-container {
            margin: 15px 0;
            text-align: center;
        }
        
        #sensitivity {
            width: 80%;
            margin: 0 auto;
        }
        
        button {
            background-color: #4CAF50;
            color: white;
            border: none;
            padding: 12px 25px;
            text-align: center;
            text-decoration: none;
            display: inline-block;
            font-size: 16px;
            margin: 15px 2px;
            cursor: pointer;
            border-radius: 50px;
            transition: all 0.3s;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
        }
        
        button:hover {
            background-color: #45a049;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.2);
        }
        
        button:active {
            transform: translateY(1px);
        }
        
        .walking {
            background-color: #e3f2fd;
        }
        
        .standing {
            background-color: #f5f5f5;
        }
        
        .error {
            color: red;
            margin: 10px 0;
        }
        
        #debug {
            font-size: 12px;
            margin-top: 10px;
            max-height: 100px;
            overflow-y: auto;
            background-color: #f0f0f0;
            padding: 5px;
            border-radius: 5px;
            display: none;
        }
        
        #confidence-meter {
            width: 100%;
            height: 20px;
            background-color: #ddd;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
        }
        
        #confidence-bar {
            height: 100%;
            width: 0%;
            background-color: #4CAF50;
            border-radius: 10px;
            transition: width 0.3s;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>D√©tecteur de Marche Am√©lior√©</h1>
        <div id="icon">üßç</div>
        <div id="status">Statut: En attente de permission</div>
        
        <div id="confidence-meter">
            <div id="confidence-bar"></div>
        </div>
        
        <div id="stats">
            <p>Acc√©l√©ration X: <span id="accelX">0</span> m/s¬≤</p>
            <p>Acc√©l√©ration Y: <span id="accelY">0</span> m/s¬≤</p>
            <p>Acc√©l√©ration Z: <span id="accelZ">0</span> m/s¬≤</p>
            <p>Magnitude: <span id="magnitude">0</span> m/s¬≤</p>
            <p>Steps d√©tect√©s: <span id="steps">0</span></p>
            <p>Variance: <span id="variance">0</span></p>
        </div>
        
        <div id="sensitivity-container">
            <label for="sensitivity">Sensibilit√©:</label>
            <input type="range" id="sensitivity" min="1" max="20" value="10">
            <span id="sensitivity-value">10</span>
        </div>
        
        <button id="startBtn">Commencer la d√©tection</button>
        <button id="calibrateBtn" style="display: none; background-color: #2196F3;">Calibrer</button>
        <div id="errorMsg" class="error"></div>
        <div id="debug"></div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const startBtn = document.getElementById('startBtn');
            const calibrateBtn = document.getElementById('calibrateBtn');
            const statusEl = document.getElementById('status');
            const iconEl = document.getElementById('icon');
            const errorMsgEl = document.getElementById('errorMsg');
            const accelXEl = document.getElementById('accelX');
            const accelYEl = document.getElementById('accelY');
            const accelZEl = document.getElementById('accelZ');
            const magnitudeEl = document.getElementById('magnitude');
            const stepsEl = document.getElementById('steps');
            const varianceEl = document.getElementById('variance');
            const debugEl = document.getElementById('debug');
            const sensitivityEl = document.getElementById('sensitivity');
            const sensitivityValueEl = document.getElementById('sensitivity-value');
            const confidenceBarEl = document.getElementById('confidence-bar');
            
            // Param√®tres ajustables
            let sensitivity = 10; // Sensibilit√© (1-20)
            sensitivityEl.value = sensitivity;
            sensitivityValueEl.textContent = sensitivity;
            
            // Variables pour la d√©tection
            let isWalking = false;
            let detectionActive = false;
            let accelerometer = null;
            let stepCount = 0;
            let lastStepTime = 0;
            
            // Fen√™tre glissante pour les mesures d'acc√©l√©ration
            const windowSize = 20;
            let accelerationWindow = Array(windowSize).fill(0);
            let windowIndex = 0;
            
            // Variables pour le suivi des mod√®les de marche
            let lastMagnitudes = [];
            const patternSize = 30; // Taille du mod√®le √† analyser
            let walkingConfidence = 0;
            let standingCounter = 0;
            let walkingCounter = 0;
            
            // Variables pour la calibration
            let isCalibrating = false;
            let standingThreshold = 0.5;
            let walkingThreshold = 1.8;
            let calibrationData = {
                standing: [],
                walking: []
            };
            
            sensitivityEl.addEventListener('input', function() {
                sensitivity = parseInt(this.value);
                sensitivityValueEl.textContent = sensitivity;
            });
            
            startBtn.addEventListener('click', startDetection);
            calibrateBtn.addEventListener('click', startCalibration);
            
            function startDetection() {
                if (detectionActive) return;
                
                errorMsgEl.textContent = '';
                
                if ('DeviceMotionEvent' in window) {
                    // V√©rifier si nous avons besoin de demander la permission (iOS 13+)
                    if (typeof DeviceMotionEvent.requestPermission === 'function') {
                        DeviceMotionEvent.requestPermission()
                            .then(response => {
                                if (response === 'granted') {
                                    setupMotionDetection();
                                } else {
                                    errorMsgEl.textContent = 'Permission refus√©e pour acc√©der √† l\'acc√©l√©rom√®tre.';
                                }
                            })
                            .catch(error => {
                                errorMsgEl.textContent = `Erreur: ${error.message}`;
                            });
                    } else {
                        // Pas besoin de permission sur Android et d'autres plateformes
                        setupMotionDetection();
                    }
                } else if ('Accelerometer' in window) {
                    try {
                        accelerometer = new Accelerometer({ frequency: 60 });
                        accelerometer.addEventListener('reading', handleAccelerometerReading);
                        accelerometer.start();
                        detectionActive = true;
                        updateUIForDetectionStart();
                    } catch (error) {
                        errorMsgEl.textContent = `Erreur: ${error.message}`;
                    }
                } else {
                    errorMsgEl.textContent = 'D√©sol√©, votre appareil ne prend pas en charge la d√©tection de mouvement.';
                }
            }
            
            function setupMotionDetection() {
                window.addEventListener('devicemotion', handleMotionEvent);
                detectionActive = true;
                updateUIForDetectionStart();
            }
            
            function updateUIForDetectionStart() {
                startBtn.textContent = 'D√©tection en cours...';
                startBtn.disabled = true;
                calibrateBtn.style.display = 'inline-block';
                statusEl.textContent = 'Statut: √Ä l\'arr√™t';
                document.body.classList.add('standing');
            }
            
            function handleMotionEvent(event) {
                const acceleration = event.acceleration || { x: 0, y: 0, z: 0 };
                let x = acceleration.x || 0;
                let y = acceleration.y || 0;
                let z = acceleration.z || 0;
                
                // Si accelerationIncludingGravity est disponible mais pas acceleration
                if ((x === 0 && y === 0 && z === 0) && event.accelerationIncludingGravity) {
                    const gravity = event.accelerationIncludingGravity;
                    // On essaie de soustraire approximativement la gravit√© (pas id√©al mais mieux que rien)
                    x = gravity.x - 0;
                    y = gravity.y - 9.8; // Approx. de la gravit√©
                    z = gravity.z - 0;
                }
                
                processAcceleration(x, y, z);
            }
            
            function handleAccelerometerReading() {
                processAcceleration(accelerometer.x, accelerometer.y, accelerometer.z);
            }
            
            function processAcceleration(x, y, z) {
                // Mise √† jour des valeurs affich√©es
                accelXEl.textContent = x.toFixed(2);
                accelYEl.textContent = y.toFixed(2);
                accelZEl.textContent = z.toFixed(2);
                
                // Calculer la magnitude (intensit√©) de l'acc√©l√©ration
                const magnitude = Math.sqrt(x*x + y*y + z*z);
                magnitudeEl.textContent = magnitude.toFixed(2);
                
                // Ajouter √† la fen√™tre glissante
                accelerationWindow[windowIndex] = magnitude;
                windowIndex = (windowIndex + 1) % windowSize;
                
                // Ajouter √† notre mod√®le de d√©tection
                lastMagnitudes.push(magnitude);
                if (lastMagnitudes.length > patternSize) {
                    lastMagnitudes.shift();
                }
                
                // Mode calibration
                if (isCalibrating) {
                    handleCalibrationData(magnitude);
                    return;
                }
                
                // Calcul de variance pour d√©tecter la marche
                const variance = calculateVariance(accelerationWindow);
                varianceEl.textContent = variance.toFixed(4);
                
                // Utiliser un algorithme plus sophistiqu√© pour d√©tecter la marche
                detectWalking(magnitude, variance);
            }
            
            function detectWalking(magnitude, variance) {
                // Algorithme bas√© sur la variance et les pics d'acc√©l√©ration
                const varThreshold = 0.05 * (sensitivity / 10);
                const magThreshold = 1.2 * (sensitivity / 10);
                
                // D√©tection bas√©e sur la variance (mesure de r√©gularit√©)
                if (variance > varThreshold) {
                    walkingCounter++;
                    standingCounter = 0;
                } else {
                    standingCounter++;
                    walkingCounter = Math.max(0, walkingCounter - 1);
                }
                
                // D√©tection de pas bas√©e sur les pics d'acc√©l√©ration
                if (magnitude > magThreshold) {
                    const now = Date.now();
                    // S'assurer qu'il y a au moins 250ms entre les pas (pour √©viter les doublons)
                    if (now - lastStepTime > 250) {
                        stepCount++;
                        stepsEl.textContent = stepCount;
                        lastStepTime = now;
                        walkingCounter += 2; // Augmenter la confiance
                    }
                }
                
                // D√©terminer l'√©tat de marche avec hyst√©r√©sis pour √©viter les fluctuations
                const walkingConfidenceThreshold = 10;
                const standingConfidenceThreshold = 15;
                
                // Limiter les compteurs
                walkingCounter = Math.min(walkingCounter, 30);
                standingCounter = Math.min(standingCounter, 30);
                
                // Mettre √† jour la confiance
                walkingConfidence = (walkingCounter - standingCounter/2);
                
                // Mettre √† jour l'indicateur de confiance
                let confidencePercent = Math.max(0, Math.min(100, (walkingConfidence / walkingConfidenceThreshold) * 100));
                confidenceBarEl.style.width = `${confidencePercent}%`;
                confidenceBarEl.style.backgroundColor = walkingConfidence > 0 ? '#4CAF50' : '#F44336';
                
                // Changer d'√©tat avec hyst√©r√©sis pour √©viter les fluctuations
                const wasWalking = isWalking;
                if (!isWalking && walkingConfidence > walkingConfidenceThreshold) {
                    isWalking = true;
                } else if (isWalking && walkingConfidence < -standingConfidenceThreshold) {
                    isWalking = false;
                }
                
                // Si le statut a chang√©
                if (wasWalking !== isWalking) {
                    updateUI();
                }
                
                // Debug info
                // debugEl.innerHTML = `Walking Counter: ${walkingCounter}, Standing Counter: ${standingCounter}, Confidence: ${walkingConfidence.toFixed(2)}`;
            }
            
            function updateUI() {
                if (isWalking) {
                    document.body.classList.remove('standing');
                    document.body.classList.add('walking');
                    statusEl.textContent = 'Statut: En marche';
                    statusEl.style.color = '#388E3C';
                    iconEl.textContent = 'üö∂';
                } else {
                    document.body.classList.remove('walking');
                    document.body.classList.add('standing');
                    statusEl.textContent = 'Statut: √Ä l\'arr√™t';
                    statusEl.style.color = '#333';
                    iconEl.textContent = 'üßç';
                }
            }
            
            function calculateVariance(array) {
                if (array.length === 0) return 0;
                
                // Calculer la moyenne
                const mean = array.reduce((sum, value) => sum + value, 0) / array.length;
                
                // Calculer la somme des carr√©s des √©carts
                const squaredDifferences = array.map(value => {
                    const diff = value - mean;
                    return diff * diff;
                });
                
                // Calculer la variance
                return squaredDifferences.reduce((sum, value) => sum + value, 0) / array.length;
            }
            
            function startCalibration() {
                if (isCalibrating) return;
                
                isCalibrating = true;
                calibrationData = {
                    standing: [],
                    walking: []
                };
                
                calibrateBtn.textContent = 'Restez immobile (5s)...';
                calibrateBtn.disabled = true;
                
                // Premi√®re phase: calibrer l'immobilit√©
                setTimeout(() => {
                    calibrateBtn.textContent = 'Maintenant marchez (5s)...';
                    
                    // Deuxi√®me phase: calibrer la marche
                    setTimeout(() => {
                        finishCalibration();
                    }, 5000);
                }, 5000);
            }
            
            function handleCalibrationData(magnitude) {
                if (calibrateBtn.textContent.includes('immobile')) {
                    calibrationData.standing.push(magnitude);
                } else if (calibrateBtn.textContent.includes('marchez')) {
                    calibrationData.walking.push(magnitude);
                }
            }
            
            function finishCalibration() {
                isCalibrating = false;
                calibrateBtn.textContent = 'Calibrer';
                calibrateBtn.disabled = false;
                
                // Calculer les seuils bas√©s sur les donn√©es collect√©es
                if (calibrationData.standing.length > 0) {
                    const standingAvg = calibrationData.standing.reduce((a, b) => a + b, 0) / calibrationData.standing.length;
                    const standingVar = calculateVariance(calibrationData.standing);
                    standingThreshold = standingAvg + standingVar * 2;
                }
                
                if (calibrationData.walking.length > 0) {
                    const walkingAvg = calibrationData.walking.reduce((a, b) => a + b, 0) / calibrationData.walking.length;
                    const walkingVar = calculateVariance(calibrationData.walking);
                    walkingThreshold = walkingAvg - walkingVar;
                }
                
                debugEl.innerHTML += `<p>Calibration termin√©e! Seuil immobile: ${standingThreshold.toFixed(2)}, Seuil marche: ${walkingThreshold.toFixed(2)}</p>`;
                debugEl.style.display = 'block';
            }
        });
    </script>
</body>
</html>