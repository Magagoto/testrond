<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Balle Gyroscope Dégradée</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      /* Fond sombre mat avec motif SVG grille de ronds alignés */
      background: #111;
      /* SVG de fond : grille de ronds alignés + UNE SEULE ligne continue qui traverse la page de façon "aléatoire" */
      background-image: url('data:image/svg+xml;utf8,<svg width="120" height="120" xmlns="http://www.w3.org/2000/svg"><circle cx="30" cy="30" r="16" fill="none" stroke="%23222" stroke-width="1.2"/><circle cx="90" cy="30" r="16" fill="none" stroke="%23222" stroke-width="1.2"/><circle cx="30" cy="90" r="16" fill="none" stroke="%23222" stroke-width="1.2"/><circle cx="90" cy="90" r="16" fill="none" stroke="%23222" stroke-width="1.2"/><polyline points="90,0 90,30 30,30 30,90 90,90 90,120" fill="none" stroke="%23222" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" opacity="0.7"/></svg>');
      font-family: sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #ball {
      position: absolute;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: #0b03fc6e;
      background-size: 150% 150%;
      background-position: center;
      transition: background 0.3s, box-shadow 0.3s;
      /* Effet néon autour de la balle */
      box-shadow:
        0 0 24px 8px #00ffcc,
        0 0 48px 16px #2a489988,
        0 2px 16px #00ffcc44;
      z-index: 10;
      isolation: isolate;
    }
    #ball:hover {
      box-shadow:
        0 0 48px 16px #00ffcc,
        0 0 64px 24px #2a4899cc,
        0 2px 24px #00ffcc88;
    }
    #ball::after {
      content: "";
      position: absolute;
      left: 50%; top: 50%;
      width: 220px;
      height: 80px;
      pointer-events: none;
      border-radius: 50%;
      /* Effet de halo/fumée dynamique */
      transform: translate(-50%, -50%) scaleX(var(--ball-blur, 0.1));
      opacity: var(--ball-blur-opacity, 0);
      background: radial-gradient(ellipse at 60% 50%, #00ffcc55 0%, #2a4899cc 60%, #1110 100%);
      filter: blur(18px);
      transition: opacity 0.18s, transform 0.09s;
      z-index: -1;
      mix-blend-mode: lighten;
    }

    #start-btn {
      padding: 1em 2.5em;
      font-size: 1.1em;
      background: rgba(0,255,204,0.13);
      color: #00ffcc;
      border: 2px solid #00ffcc;
      border-radius: 12px;
      cursor: pointer;
      z-index: 2;
      position: absolute;
      left: 50%;
      top: 38%; /* au-dessus de la balle */
      transform: translate(-50%, -100%);
      margin-top: 0;
      font-family: 'Fira Mono', 'Consolas', monospace;
      font-weight: 600;
      box-shadow: 0 2px 16px #00ffcc22, 0 1px 8px #0004;
      backdrop-filter: blur(2px);
      letter-spacing: 1px;
      transition: background 0.3s, color 0.3s, border 0.3s, box-shadow 0.3s;
    }
    #start-btn:hover {
      background: #00ffcc;
      color: #111;
      border: 2px solid #00ffcc;
      box-shadow: 0 0 24px #00ffcc88;
    }

    #info {
      position: absolute;
      bottom: 20px;
      color: white;
      font-family: sans-serif;
      font-size: 0.9em;
      display: none; /* caché, le texte va dans la bannière */
    }
    
    /* Style pour les cages rectangulaires */
    .cage {
      position: absolute;
      /* Suppression des bordures */
      box-sizing: border-box;
    }
    
    /* Cages du haut */
    .cage-top {
      top: 70px;
      height: 44px;    /* encore augmenté */
      width: 37%;      /* encore augmenté */
    }
    
    #cage-top-1 {
      left: 12%;
    }
    
    #cage-top-2 {
      right: 12%;
    }
    
    /* Cages du bas */
    .cage-bottom {
      bottom: 10px;
      height: 44px;    /* encore augmenté */
      width: 37%;      /* encore augmenté */
    }
    
    #cage-bottom-1 {
      left: 12%;
    }
    
    #cage-bottom-2 {
      right: 12%;
    }
    
    /* Cages latérales (3 de chaque côté) */
    .cage-left, .cage-right {
      width: 44px;     /* encore augmenté */
      height: 20%;     /* encore augmenté */
    }
    
    #cage-left-1 {
      left: 10px;
      top: 20%;
    }
    
    #cage-left-2 {
      left: 10px;
      top: 42.5%;
    }
    
    #cage-left-3 {
      left: 10px;
      top: 65%;
    }
    
    #cage-right-1 {
      right: 10px;
      top: 20%;
    }
    
    #cage-right-2 {
      right: 10px;
      top: 42.5%;
    }
    
    #cage-right-3 {
      right: 10px;
      top: 65%;
    }

    /* Styles pour les coins des cages */
    .cage-corner {
      position: absolute;
      background: white;
    }

    /* Coins pour les cages du haut */
    .cage-top .corner-left {
      top: 0;
      left: -10px; /* Positionner à gauche */
      width: 10px; /* Rectangle vertical */
      height: 180%; /* Allonger la hauteur */
    }
    .cage-top .corner-right {
      top: 0;
      right: -10px; /* Positionner à droite */
      width: 10px; /* Rectangle vertical */
      height: 180%; /* Allonger la hauteur */
    }

    /* Coins pour les cages du bas */
    .cage-bottom .corner-left {
      bottom: 0;
      left: -10px; /* Positionner à gauche */
      width: 10px; /* Rectangle vertical */
      height: 180%; /* Allonger la hauteur */
    }
    .cage-bottom .corner-right {
      bottom: 0;
      right: -10px; /* Positionner à droite */
      width: 10px; /* Rectangle vertical */
      height: 180%; /* Allonger la hauteur */
    }

    /* Coins pour les cages latérales gauche */
    .cage-left .corner-top {
      top: -10px; /* Positionner en haut */
      left: 0;
      width: 180%; /* Allonger la largeur */
      height: 10px; /* Rectangle horizontal */
    }
    .cage-left .corner-bottom {
      bottom: -10px; /* Positionner en bas */
      left: 0;
      width: 180%; /* Allonger la largeur */
      height: 10px; /* Rectangle horizontal */
    }

    /* Coins pour les cages latérales droite */
    .cage-right .corner-top {
      top: -10px; /* Positionner en haut */
      right: 0;
      width: 180%; /* Allonger la largeur */
      height: 10px; /* Rectangle horizontal */
    }
    .cage-right .corner-bottom {
      bottom: -10px; /* Positionner en bas */
      right: 0;
      width: 180%; /* Allonger la largeur */
      height: 10px; /* Rectangle horizontal */
    }

    @keyframes blink {
        from { opacity: 1; }
        to { opacity: 0.3; }
    }

    /* Bannière en haut */
    #game-banner {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      min-width: 340px;
      max-width: 100vw;
      height: 68px; /* plus large */
      background: linear-gradient(180deg, #182c4c 0%, #111 100%) !important; /* bleu plus foncé */
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      box-shadow: 0 2px 8px #0008;
      gap: 32px; /* espace entre les éléments */
    }
    #banner-content {
      width: 100%;
      max-width: 900px;
      display: flex;
      justify-content: flex-start; /* aligner à gauche */
      align-items: center;
      padding: 0 30px;
      gap: 32px; /* espace entre les éléments */
    }
    #timer-display {
      position: static;
      color: white;
      font-size: 24px;
      font-weight: bold;
      font-family: sans-serif;
      z-index: 10;
      margin: 0 10px;
      margin-right: 12px; /* espace à droite du chrono */
    }
    #score-display {
      position: static;
      color: white;
      font-size: 24px;
      font-weight: bold;
      margin: 0 10px;
    }
    #gyro-status {
      color: #00ffcc;
      font-family: 'Fira Mono', 'Consolas', monospace;
      font-size: 1.1em;
      font-weight: 600;
      letter-spacing: 1px;
      text-shadow: 0 0 8px #00ffcc, 0 0 2px #fff;
      margin-left: 24px;
      transition: opacity 0.3s;
      opacity: 0;
      animation: none;
    }
    #gyro-status.active {
      opacity: 1;
      animation: blink 1.2s infinite alternate;
    }

    /* Style pour le pop-up du tutoriel */
    .tutorial-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.85);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }

    .tutorial-overlay.active {
      opacity: 1;
      pointer-events: all;
    }

    .tutorial-container {
      position: relative;
      width: 95%;
      max-width: 800px; /* augmenté de 500px à 800px */
      max-height: 88vh;
      overflow-y: auto;
      background: linear-gradient(145deg, #182c4c 0%, #111 100%);
      border: 2px solid #00ffcc;
      border-radius: 16px;
      padding: 24px;
      color: white;
      box-shadow: 0 0 30px #00ffcc44, 0 0 15px #2a489966;
      margin: 0 10px;
    }

    .tutorial-header {
      text-align: center;
      margin-bottom: 20px;
      color: #00ffcc;
      text-shadow: 0 0 10px #00ffcc66;
      font-family: 'Fira Mono', 'Consolas', monospace;
      letter-spacing: 1px;
    }

    .tutorial-header h2 {
      font-size: 2em;
      font-weight: 600;
      margin: 0.5em 0;
    }

    .tutorial-content {
      margin-bottom: 24px;
      line-height: 1.6;
      font-family: sans-serif;
      font-size: 18px; /* augmenté de 16px */
    }

    .tutorial-step {
      display: flex;
      margin-bottom: 24px;
      padding-bottom: 8px;
      align-items: flex-start;
    }

    .step-number {
      background: #00ffcc;
      color: #111;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      margin-right: 18px;
      flex-shrink: 0;
      font-family: 'Fira Mono', 'Consolas', monospace;
      font-size: 20px;
    }

    .tutorial-btn {
      padding: 1em 2em;
      font-size: 1.2em;
      background: rgba(0,255,204,0.13);
      color: #00ffcc;
      border: 2px solid #00ffcc;
      border-radius: 12px;
      cursor: pointer;
      font-family: 'Fira Mono', 'Consolas', monospace;
      font-weight: 600;
      box-shadow: 0 2px 16px #00ffcc22, 0 1px 8px #0004;
      backdrop-filter: blur(2px);
      letter-spacing: 1px;
      transition: background 0.3s, color 0.3s, border 0.3s, box-shadow 0.3s;
      display: block;
      margin: 0 auto;
      text-align: center;
      width: 100%;
      max-width: 320px; /* augmenté de 280px */
    }

    .highlight {
      color: #00ffcc;
      font-weight: bold;
      text-shadow: 0 0 6px #00ffcc33;
    }

    /* Ajustements spécifiques pour mobile et tablette */
    @media (max-width: 800px) {
      .tutorial-container {
        padding: 24px;
        width: 98%;
        max-width: none; /* prend toute la largeur disponible */
        max-height: 94vh;
        border-radius: 12px;
        margin: 10px auto;
      }
      
      .tutorial-header h2 {
        font-size: 2.4em;
        margin-bottom: 0.6em;
      }
      
      .tutorial-content {
        font-size: 1.5em;
        line-height: 1.5;
      }
      
      .step-number {
        width: 50px;
        height: 50px;
        font-size: 24px;
        margin-right: 20px;
      }
      
      .tutorial-btn {
        margin-top: 20px;
        padding: 1.2em 1em;
        font-size: 1.6em;
        max-width: 90%; /* prend 90% de la largeur du conteneur */
        border-radius: 14px;
      }
      
      /* Ajuster l'espacement des paragraphes pour une meilleure lisibilité */
      .tutorial-step p {
        margin: 1em 0;
      }
      
      /* Augmenter l'espace entre les étapes */
      .tutorial-step {
        margin-bottom: 36px;
        padding-bottom: 14px;
      }
    }

    /* Ajustements pour les téléphones */
    @media (max-width: 480px) {
      .tutorial-container {
        padding: 20px;
        width: 100%;
        max-height: 96vh;
        border-radius: 10px;
        margin: 5px 0;
        border-width: 1px;
      }
      
      .tutorial-content {
        font-size: 1.3em;
      }
      
      .step-number {
        width: 46px;
        height: 46px;
        margin-right: 16px;
      }
      
      .tutorial-btn {
        max-width: 100%;
        margin-top: 10px;
      }
    }

    /* Ajustements pour les très petits écrans */
    @media (max-width: 320px) {
      .tutorial-container {
        padding: 15px;
      }
      
      .tutorial-header h2 {
        font-size: 2em;
      }
      
      .tutorial-content {
        font-size: 1.2em;
      }
      
      .step-number {
        width: 40px;
        height: 40px;
        font-size: 20px;
        margin-right: 12px;
      }
    }

    /* Responsive : bannière plus large sur mobile */
    @media (max-width: 600px) {
      #game-banner {
        height: 80px;
        min-width: 100vw;
        padding-left: 0;
        padding-right: 0;
        background: linear-gradient(180deg, #182c4c 0%, #111 100%) !important;
      }
      #banner-content {
        max-width: 100vw;
        padding: 0 8px;
      }
    }

    /* Style pour l'affichage du score final */
    .score-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      transition: opacity 1s, background-color 1s;
      pointer-events: none;
    }

    .score-overlay.active {
      opacity: 1;
      background-color: rgba(0, 0, 0, 0.85);
      pointer-events: all;
    }

    .score-container {
      position: relative;
      width: 95%;
      max-width: 500px;
      background: linear-gradient(145deg, #182c4c 0%, #111 100%);
      border: 2px solid #00ffcc;
      border-radius: 16px;
      padding: 30px;
      color: white;
      box-shadow: 0 0 30px #00ffcc44, 0 0 15px #2a489966;
      text-align: center;
      transform: translateY(30px);
      opacity: 0;
      transition: transform 0.8s ease-out, opacity 0.8s ease-out;
    }

    .score-overlay.active .score-container {
      transform: translateY(0);
      opacity: 1;
    }

    .score-header {
      margin-bottom: 30px;
      color: #00ffcc;
      text-shadow: 0 0 10px #00ffcc66;
      font-family: 'Fira Mono', 'Consolas', monospace;
      letter-spacing: 1px;
    }

    .score-header h2 {
      font-size: 2.2em;
      font-weight: 600;
      margin: 0;
    }

    .score-content {
      margin-bottom: 30px;
    }

    .final-score {
      font-size: 3.5em;
      font-weight: bold;
      margin: 20px 0;
      color: #00ffcc;
      text-shadow: 0 0 15px #00ffcc88;
      font-family: 'Fira Mono', 'Consolas', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }

    .score-label {
      font-size: 0.4em;
      opacity: 0.8;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .score-message {
      font-size: 1.3em;
      opacity: 0.9;
      margin-top: 20px;
    }

    .score-btn {
      padding: 1em 2em;
      font-size: 1.2em;
      background: rgba(0,255,204,0.13);
      color: #00ffcc;
      border: 2px solid #00ffcc;
      border-radius: 12px;
      cursor: pointer;
      font-family: 'Fira Mono', 'Consolas', monospace;
      font-weight: 600;
      box-shadow: 0 2px 16px #00ffcc22, 0 1px 8px #0004;
      backdrop-filter: blur(2px);
      letter-spacing: 1px;
      transition: background 0.3s, color 0.3s, border 0.3s, box-shadow 0.3s;
      display: block;
      margin: 0 auto;
      width: 100%;
      max-width: 300px;
    }

    .score-btn:hover {
      background: #00ffcc;
      color: #111;
      border: 2px solid #00ffcc;
      box-shadow: 0 0 24px #00ffcc88;
    }

    @media (max-width: 600px) {
      .score-container {
        width: 90%;
        padding: 25px;
      }
      
      .score-header h2 {
        font-size: 2em;
      }
      
      .final-score {
        font-size: 3em;
      }
      
      .score-message {
        font-size: 1.1em;
      }
      
      .score-btn {
        font-size: 1.1em;
        padding: 0.9em 1.5em;
      }
    }
  </style>
</head>
<body>
  <!-- Bannière du jeu -->
  <div id="game-banner">
    <div id="banner-content">
      <span id="timer-display">00:05</span>
      <span id="score-display">Score: 0</span>
      <span id="gyro-status"></span>
    </div>
  </div>

  <!-- Pop-up du tutoriel -->
  <div class="tutorial-overlay" id="tutorial-overlay">
    <div class="tutorial-container">
      <div class="tutorial-header">
        <h2>Rite d'Alignement Énergétique</h2>
      </div>
      <div class="tutorial-content">
        <div class="tutorial-step">
          <div class="step-number">1</div>
          <div>
            <p>Bienvenue, Raffineur.</p>
            <p>Tu t'apprêtes à entamer un <span class="highlight">rite d'alignement énergétique</span>.</p>
            <p>Pour ce faire, saisis ton artefact — ton téléphone — et incline-le pour guider l'énergie jusqu'à son réceptacle.</p>
          </div>
        </div>
        
        <div class="tutorial-step">
          <div class="step-number">2</div>
          <div>
            <p>Observe sa teinte : elle t'indique la cage qui lui correspond. Il te suffit d'amener l'énergie dans un réceptacle de même couleur.</p>
            <p>Ton objectif est simple : faire correspondre la couleur de l'énergie avec celle des cages.</p>
            <p>Si les énergies s'accordent, tu gagnes <span class="highlight">+2 points</span>. En cas de dissonance, tu perds <span class="highlight">-1 point</span>.</p>
          </div>
        </div>
        
        <div class="tutorial-step">
          <div class="step-number">3</div>
          <div>
            <p>À chaque contact, l'énergie change de forme — une <span class="highlight">transmutation aléatoire</span>.</p>
            <p>Les réceptacles eux aussi sont instables : leurs dimensions fluctuent au fil du temps.</p>
          </div>
        </div>
        
        <div class="tutorial-step">
          <div class="step-number">4</div>
          <div>
            <p><span class="highlight">⏱ Tu as 1 minute et 10 secondes</span> pour affiner ta trajectoire et récolter un maximum de points.</p>
            <p>Respire. Ressens. Laisse-toi guider par l'équilibre.</p>
            <p>Bonne chance, Raffineur.</p>
          </div>
        </div>
      </div>
      <button class="tutorial-btn" id="tutorial-close-btn">J'ai compris, commencer le rite</button>
    </div>
  </div>

  <!-- Ajout de la superposition pour l'affichage du score final -->
  <div class="score-overlay" id="score-overlay">
    <div class="score-container">
      <div class="score-header">
        <h2>Raffinage Terminé</h2>
      </div>
      <div class="score-content">
        <div class="final-score">
          <span id="final-score-value">0</span>
          <span class="score-label">points</span>
        </div>
        <p class="score-message">Ton alignement énergétique est achevé.</p>
      </div>
      <button class="score-btn" id="restart-btn">Retourner à la page principale</button>
    </div>
  </div>

  <button id="start-btn">Activer le gyroscope</button>
  <div id="ball"></div>
  <div id="info"></div>
  
  <!-- Ajout des éléments audio -->
  <audio id="pointSound" src="SONORE/1point+.mp3" preload="auto"></audio>
  <audio id="backgroundMusic" src="SONORE/ambiancegyro.mp3" loop preload="auto"></audio>
  <audio id="endGameSound" src="SONORE/Fin de raffinage.mp3" preload="auto"></audio>
  
  <!-- Cages rectangulaires -->
  <div id="cage-top-1" class="cage cage-top">
    <div class="cage-corner corner-left"></div>
    <div class="cage-corner corner-right"></div>
  </div>
  <div id="cage-top-2" class="cage cage-top">
    <div class="cage-corner corner-left"></div>
    <div class="cage-corner corner-right"></div>
  </div>
  
  <div id="cage-bottom-1" class="cage cage-bottom">
    <div class="cage-corner corner-left"></div>
    <div class="cage-corner corner-right"></div>
  </div>
  <div id="cage-bottom-2" class="cage cage-bottom">
    <div class="cage-corner corner-left"></div>
    <div class="cage-corner corner-right"></div>
  </div>
  
  <div id="cage-left-1" class="cage cage-left">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>
  <div id="cage-left-2" class="cage cage-left">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>
  <div id="cage-left-3" class="cage cage-left">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>
  
  <div id="cage-right-1" class="cage cage-right">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>
  <div id="cage-right-2" class="cage cage-right">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>
  <div id="cage-right-3" class="cage cage-right">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>

  <script>
    const ball = document.getElementById("ball");
    const startBtn = document.getElementById("start-btn");
    const info = document.getElementById("info");
    const pointSound = document.getElementById("pointSound");
    const backgroundMusic = document.getElementById("backgroundMusic"); // Ajout de la référence à la musique
    const endGameSound = document.getElementById("endGameSound"); // Ajout de la référence au son de fin
    const gyroStatus = document.getElementById("gyro-status");
    
    // Éléments du tutoriel
    const tutorialOverlay = document.getElementById("tutorial-overlay");
    const tutorialCloseBtn = document.getElementById("tutorial-close-btn");

    // Éléments pour l'affichage du score final
    const scoreOverlay = document.getElementById("score-overlay");
    const finalScoreValue = document.getElementById("final-score-value");
    const restartBtn = document.getElementById("restart-btn");

    // Afficher le tutoriel au chargement de la page
    window.addEventListener("DOMContentLoaded", () => {
      // Attendre un peu avant d'afficher pour permettre le chargement complet
      setTimeout(() => {
        tutorialOverlay.classList.add("active");
      }, 500);
    });

    // Fermer le tutoriel quand le bouton est cliqué
    tutorialCloseBtn.addEventListener("click", () => {
      tutorialOverlay.classList.remove("active");
      preloadSounds();
    });

    // Écouteur d'événement pour le bouton de redémarrage
    restartBtn.addEventListener("click", () => {
      scoreOverlay.classList.remove("active");
      startBtn.style.display = "block";
      // Réinitialiser la position de la balle
      posX = window.innerWidth / 2;
      posY = window.innerHeight / 2;
      velX = 0;
      velY = 0;
      ball.style.left = posX + "px";
      ball.style.top = posY + "px";
    });

    // Dégradés cycliques prédéfinis
    const gradients = [
      ["#00A993", "#E68B4A"],
      ["#E68B4A", "#7A1619"],
      ["#7A1619", "#362777"],
      ["#362777", "#EB7AAE"],
      ["#EB7AAE", "#0069AA"],
      ["#0069AA", "#DC0C15"],
      ["#DC0C15", "#E03A8D"],
      ["#E03A8D", "#FFFFFF"],
      ["#FFFFFF", "#2A4899"],
      ["#2A4899", "#00A993"]
    ];

    const scoreDisplay = document.getElementById("score-display");
    const timerDisplay = document.getElementById("timer-display");

    let score = 0;
    let gameActive = false;
    let timerSeconds = 5; // Durée de la partie en secondes (réduite à 5 secondes)
    let timerInterval;
    updateScoreDisplay();

    // Fonction pour mettre à jour l'affichage du score
    function updateScoreDisplay() {
      scoreDisplay.textContent = `Score: ${score}`;
    }

    // Assigner des identifiants uniques à chaque gradient pour pouvoir les comparer
    const gradientIds = {};
    gradients.forEach((gradient, index) => {
      gradientIds[`${gradient[0]}_${gradient[1]}`] = index;
    });

    // Fonction pour déterminer si deux couleurs sont similaires
    function areSimilarColors(color1, color2) {
      const rgb1 = colorToRgb(color1);
      const rgb2 = colorToRgb(color2);
      if (!rgb1 || !rgb2) return false;
      const distance = Math.sqrt(
        Math.pow(rgb1.r - rgb2.r, 2) +
        Math.pow(rgb1.g - rgb2.g, 2) +
        Math.pow(rgb1.b - rgb2.b, 2)
      );
      const tolerance = 30;
      return distance < tolerance;
    }

    // Fonction pour convertir une couleur (hex ou rgb) en valeurs RGB
    function colorToRgb(color) {
      const rgbMatch = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
      if (rgbMatch) {
        return {
          r: parseInt(rgbMatch[1]),
          g: parseInt(rgbMatch[2]),
          b: parseInt(rgbMatch[3])
        };
      }
      const hexMatch = color.match(/#([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})/);
      if (hexMatch) {
        return {
          r: parseInt(hexMatch[1], 16),
          g: parseInt(hexMatch[2], 16),
          b: parseInt(hexMatch[3], 16)
        };
      }
      return null;
    }

    // Appliquer un dégradé différent à chaque cage
    function assignUniqueGradients() {
      const cages = document.querySelectorAll('.cage');
      
      // Créer une copie du tableau de gradients pour pouvoir en retirer au fur et à mesure
      let availableGradients = [...gradients];
      
      // Mélanger le tableau pour une attribution aléatoire
      availableGradients = shuffleArray(availableGradients);
      
      // Assigner un dégradé unique à chaque cage
      cages.forEach((cage, index) => {
        if (index < availableGradients.length) {
          const gradient = availableGradients[index];
          cage.style.background = `linear-gradient(135deg, ${gradient[0]}, ${gradient[1]})`;
        }
      });
    }
    
    // Fonction pour mélanger un tableau (algorithme de Fisher-Yates)
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // Appliquer un dégradé aléatoire à la balle
    let currentBallGradientIndex = Math.floor(Math.random() * gradients.length);
    ball.style.background = `linear-gradient(135deg, ${gradients[currentBallGradientIndex][0]}, ${gradients[currentBallGradientIndex][1]})`;

    // Assigner des dégradés uniques aux cages
    assignUniqueGradients();

    // Met à jour la couleur des coins selon le dégradé réel appliqué en CSS
    function updateCornerColors() {
      const cages = document.querySelectorAll('.cage');
      cages.forEach(cage => {
        // Récupérer le style de fond actuel de la cage
        const computedStyle = window.getComputedStyle(cage);
        const backgroundImage = computedStyle.backgroundImage;
        
        // Extraire les couleurs du gradient
        let colorStart, colorEnd;
        
        // Extraire les couleurs depuis la propriété backgroundImage
        const colors = backgroundImage.match(/(#[0-9A-Fa-f]{6}|rgb\([^)]+\))/gi);
        if (colors && colors.length >= 2) {
          colorStart = colors[0];
          colorEnd = colors[1];
        } else {
          // Valeurs par défaut si on ne peut pas extraire les couleurs
          colorStart = "#FFFFFF";
          colorEnd = "#CCCCCC";
        }

        const corners = cage.querySelectorAll('.cage-corner');
        corners.forEach(corner => {
          // Cages du haut et du bas
          if (cage.classList.contains('cage-top') || cage.classList.contains('cage-bottom')) {
            if (corner.classList.contains('corner-left')) {
              corner.style.background = colorStart;
            }
            if (corner.classList.contains('corner-right')) {
              corner.style.background = colorEnd;
            }
          }
          // Cages de gauche
          else if (cage.classList.contains('cage-left')) {
            if (corner.classList.contains('corner-top')) {
              corner.style.background = colorStart;
            }
            if (corner.classList.contains('corner-bottom')) {
              corner.style.background = colorEnd;
            }
          }
          // Cages de droite
          else if (cage.classList.contains('cage-right')) {
            if (corner.classList.contains('corner-top')) {
              corner.style.background = colorStart;
            }
            if (corner.classList.contains('corner-bottom')) {
              corner.style.background = colorEnd;
            }
          }
        });
      });
    }

    // On doit appeler updateCornerColors APRÈS assignUniqueGradients
    updateCornerColors();

    let posX = window.innerWidth / 2;
    let posY = window.innerHeight / 2;
    let velX = 0;
    let velY = 0;

    const ballSize = 80;
    const friction = 0.98;
    
    // Réduction IMPORTANTE de la sensibilité (avant: 0.15)
    const accelerationFactor = 0.01;
    
    // Variable pour suivre le dernier changement de couleur
    let lastColorChange = 0;
    const colorChangeDelay = 300; // Délai minimum entre les changements de couleur (ms)

    function updateBallPosition() {
      posX += velX;
      posY += velY;

      // Vérifier les collisions avec les bords de l'écran
      if (posX <= 0) {
        posX = 0;
        velX *= -0.7;
      } else if (posX >= window.innerWidth - ballSize) {
        posX = window.innerWidth - ballSize;
        velX *= -0.7;
      }

      if (posY <= 0) {
        posY = 0;
        velY *= -0.7;
      } else if (posY >= window.innerHeight - ballSize) {
        posY = window.innerHeight - ballSize;
        velY *= -0.7;
      }

      // Collision avec les cages rectangulaires
      checkCageCollisions();

      velX *= friction;
      velY *= friction; (1.2);

      // Effet de vitesse (motion blur) selon la vitesse de la balle
      const speed = Math.sqrt(velX * velX + velY * velY);
      const blurScale = Math.min(1.5, speed * 0.7);
      const blurOpacity = Math.min(0.55, speed * 0.18);
      ball.style.setProperty('--ball-blur', blurScale.toFixed(2));
      ball.style.setProperty('--ball-blur-opacity', blurOpacity.toFixed(2));

      ball.style.left = posX + "px";
      ball.style.top = posY + "px";

      requestAnimationFrame(updateBallPosition);
    }

    function changeBallColor() {
      const now = Date.now();
      // Vérifier si on peut changer la couleur (pour éviter les changements trop rapides)
      if (now - lastColorChange >= colorChangeDelay) {
        // Choisir un nouvel index différent de l'actuel
        let newIndex;
        do {
          newIndex = Math.floor(Math.random() * gradients.length);    
        } while (newIndex === currentBallGradientIndex);
        
        currentBallGradientIndex = newIndex;
        ball.style.background = `linear-gradient(135deg, ${gradients[currentBallGradientIndex][0]}, ${gradients[currentBallGradientIndex][1]})`;
        lastColorChange = now;
      }
    }
    
    // Configuration des animations améliorées - Modifications pour des animations plus dynamiques
    const cageAnimationConfig = {
      minDuration: 2000,  // Durée minimum d'un cycle d'animation réduite (avant: 5000)
      maxDuration: 4000,  // Durée maximum d'un cycle d'animation réduite (avant: 9000)
      minSize: 0.6,       // Taille minimum plus petite (avant: 0.8)
      maxSize: 1.4,       // Taille maximum plus grande (avant: 1.2)
    };

    // Stocker les dimensions originales des cages
    const cageOriginalDimensions = {};

    // Variable pour suivre l'état des collisions
    const collisionCooldowns = {};

    // Ajouter une transition sur les coins pour l'animation fluide (à faire une seule fois)
    function addCornerTransitions() {
      document.querySelectorAll('.cage-corner').forEach(corner => {
        corner.style.transition = "width 0.7s, height 0.7s";
      });
    }
    addCornerTransitions();

    // Initialiser les animations des cages avec des transitions CSS plus rapides
    function initCageAnimations() {
      const cages = document.querySelectorAll('.cage');
      
      cages.forEach((cage, index) => {
        // Transition plus rapide pour des animations plus dynamiques
        cage.style.transition = "width 0.8s ease-in-out, height 0.8s ease-in-out, top 0.8s ease-in-out";

        // Stocker les dimensions originales
        const rect = cage.getBoundingClientRect();
        const style = window.getComputedStyle(cage);
        
        cageOriginalDimensions[cage.id] = {
          width: rect.width,
          height: rect.height,
          left: parseFloat(style.left || "0"),
          top: parseFloat(style.top || "0"),
          right: parseFloat(style.right || "0"),
          bottom: parseFloat(style.bottom || "0")
        };

        // Initialiser le cooldown de collision
        collisionCooldowns[cage.id] = 0;

        // Démarrer l'animation avec un délai aléatoire pour désynchroniser
        setTimeout(() => {
          animateCage(cage);
        }, Math.random() * 1000); // Délai plus court pour commencer les animations plus rapidement
      });
    }

    // Animation d'une cage individuelle avec possibilité d'animer uniquement les coins
    function animateCage(cage) {
      const original = cageOriginalDimensions[cage.id];
      const isHorizontal = cage.classList.contains('cage-top') || cage.classList.contains('cage-bottom');
      const isSideLeft = cage.classList.contains('cage-left');
      const isSideRight = cage.classList.contains('cage-right');
      const corners = cage.querySelectorAll('.cage-corner');

      // Générer des valeurs aléatoires pour cette animation
      const duration = Math.random() * 
        (cageAnimationConfig.maxDuration - cageAnimationConfig.minDuration) + 
        cageAnimationConfig.minDuration;
      const sizeFactor1 = Math.random() * 
        (cageAnimationConfig.maxSize - cageAnimationConfig.minSize) + 
        cageAnimationConfig.minSize;
      const sizeFactor2 = Math.random() * 
        (cageAnimationConfig.maxSize - cageAnimationConfig.minSize) + 
        cageAnimationConfig.minSize;

      // 30% de chance d'animer uniquement les coins
      const onlyCorners = Math.random() < 0.3;

      // 20% de chance d'allonger ENCORE PLUS les coins (super allongement)
      const superLongCorners = onlyCorners && Math.random() < 0.2;

      if (onlyCorners) {
        // Remettre la cage principale à sa taille d'origine
        if (isHorizontal) {
          cage.style.width = `${original.width}px`;
          cage.style.height = `${original.height}px`;
        } else if (isSideLeft || isSideRight) {
          cage.style.width = `${original.width}px`;
          cage.style.height = `${original.height}px`;
        }

        // Allonger fortement les coins, ou ENCORE PLUS si superLongCorners
        corners.forEach(corner => {
          if (isHorizontal) {
            // Coins verticaux : on allonge la hauteur
            if (superLongCorners) {
              corner.style.height = `${original.height * 7}px`; // super allongé
            } else {
              corner.style.height = `${original.height * 3.5}px`; // très allongé
            }
            corner.style.width = `10px`;
          } else if (isSideLeft || isSideRight) {
            // Coins horizontaux : on allonge la largeur
            if (superLongCorners) {
              corner.style.width = `${original.width * 7}px`; // super allongé
            } else {
              corner.style.width = `${original.width * 3.5}px`; // très allongé
            }
            corner.style.height = `10px`;
          }
        });
      } else {
        // Animation normale de la cage principale
        if (isHorizontal) {
          const newWidth = original.width * sizeFactor1;
          const newHeight = original.height * sizeFactor2;
          cage.style.width = `${newWidth}px`;
          cage.style.height = `${newHeight}px`;
          if (cage.classList.contains('cage-top-1') || cage.classList.contains('cage-bottom-1')) {
            const newLeft = original.left + (Math.random() * 20 - 10);
            cage.style.left = `${newLeft}px`;
          };
        } else if (isSideLeft || isSideRight) {
          const newHeight = original.height * sizeFactor1;
          const newWidth = original.width * sizeFactor2;
          cage.style.height = `${newHeight}px`;
          cage.style.width = `${newWidth}px`;
          const deltaHeight = newHeight - original.height;
          const newTop = Math.max(0, original.top - (deltaHeight / 2) + (Math.random() * 20 - 10));
          cage.style.top = `${newTop}px`;
        }
        // Remettre les coins à leur taille normale
        corners.forEach(corner => {
          if (isHorizontal) {
            corner.style.height = `180%`;
            corner.style.width = `10px`;
          } else if (isSideLeft || isSideRight) {
            corner.style.width = `180%`;
            corner.style.height = `10px`;
          }
        });
      }

      setTimeout(() => {
        updateCageCorners(cage);
      }, 100);

      setTimeout(() => {
        animateCage(cage);
      }, duration);
    }

    // Fonction pour mettre à jour les positions des coins en fonction de l'animation des cages
    function updateCageCorners(cage) {
      // Les coins restent positionnés en relatif, donc rien à faire ici pour l'instant
    }

    // Mise à jour de la fonction de détection de collision avec période de grâce
    function checkCageCollisions() {
      const cages = document.querySelectorAll('.cage');
      const ballRadius = ballSize / 2;
      const ballCenterX = posX + ballRadius;
      const ballCenterY = posY + ballRadius;

      const now = Date.now();
      let collisionDetected = false;

      cages.forEach(cage => {
        // Vérifier si cette cage est en période de cooldown
        if (collisionCooldowns[cage.id] > now) {
          return; // Ignorer cette cage pendant sa période de cooldown
        }

        // Utiliser getBoundingClientRect pour obtenir les dimensions et positions actuelles
        const cageRect = cage.getBoundingClientRect();

        // Vérifier si la balle touche une cage
        if (ballCenterX + ballRadius > cageRect.left &&
            ballCenterX - ballRadius < cageRect.right &&
            ballCenterY + ballRadius > cageRect.top &&
            ballCenterY - ballRadius < cageRect.bottom) {

          collisionDetected = true;

          // Déterminer de quel côté la collision a eu lieu
          const dx = ballCenterX - (cageRect.left + cageRect.width / 2);
          const dy = ballCenterY - (cageRect.top + cageRect.height / 2);

          // Rebond en fonction de la direction de la collision
          if (Math.abs(dx) > Math.abs(dy)) {
            // Collision horizontale
            velX *= -0.7;
            if (dx > 0) {
              // Collision à gauche
              posX = cageRect.right;
            } else {
              // Collision à droite
              posX = cageRect.left - ballSize;
            }
          } else {
            // Collision verticale
            velY *= -0.7;
            if (dy > 0) {
              // Collision en haut
              posY = cageRect.bottom;
            } else {
              // Collision en bas
              posY = cageRect.top - ballSize;
            }
          }

          // Comparer le gradient de la balle avec celui de la cage (code existant)
          const computedStyle = window.getComputedStyle(cage);
          const cageGradient = computedStyle.backgroundImage;
          const cageColors = cageGradient.match(/(#[0-9A-Fa-f]{6}|rgb\([^)]+\))/gi);

          const ballStyle = window.getComputedStyle(ball);
          const ballGradient = ballStyle.backgroundImage;
          const ballColors = ballGradient.match(/(#[0-9A-Fa-f]{6}|rgb\([^)]+\))/gi);

          // Créer un effet visuel pour montrer le changement de score
          const scoreEffect = document.createElement("div");
          scoreEffect.style.position = "absolute";
          scoreEffect.style.left = `${ballCenterX}px`;
          scoreEffect.style.top = `${ballCenterY - 30}px`;
          scoreEffect.style.fontFamily = "sans-serif";
          scoreEffect.style.fontSize = "20px";
          scoreEffect.style.fontWeight = "bold";
          scoreEffect.style.zIndex = "20";
          scoreEffect.style.transition = "transform 0.5s, opacity 0.5s";

          // Comparer les gradients en utilisant l'apparence visuelle (similaire)
          if (cageColors && ballColors &&
              areSimilarColors(cageColors[0], ballColors[0]) &&
              areSimilarColors(cageColors[1], ballColors[1])) {
            // Même gradient, +2 points (au lieu de +1)
            score += 2;
            scoreEffect.textContent = "+2";
            scoreEffect.style.color = "#00FF00";
            pointSound.play(); // Jouer le son lors d'un point gagné
          } else {
            // Gradient différent, -1 point (inchangé)
            score -= 1;
            scoreEffect.textContent = "-1";
            scoreEffect.style.color = "#FF0000";
          }

          document.body.appendChild(scoreEffect);

          // Animation de l'effet de score
          setTimeout(() => {
            scoreEffect.style.transform = "translateY(-30px)";
            scoreEffect.style.opacity = "0";
          }, 10);

          // Suppression de l'effet après l'animation
          setTimeout(() => {
            if (scoreEffect.parentNode) {
              document.body.removeChild(scoreEffect);
            }
          }, 600);

          // Mettre à jour l'affichage du score
          updateScoreDisplay();

          // Changer la couleur de la balle lors d'une collision
          changeBallColor();

          // Mettre la cage en cooldown pour éviter les collisions multiples rapides
          collisionCooldowns[cage.id] = now + 400;
        }
      });

      return collisionDetected;
    }

    // Ajouter cette fonction pour actualiser les animations régulièrement
    function updateAnimations() {
      requestAnimationFrame(updateAnimations);
    }
    updateAnimations();

    function startGyro() {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(permissionState => {
                    if (permissionState === 'granted') {
                        initGame();
                    } else {
                        info.textContent = "Permission refusée ❌";
                        gyroStatus.textContent = "Permission refusée ❌";
                        gyroStatus.classList.remove("active");
                        gyroStatus.style.opacity = 1;
                    }
                })
                .catch(console.error);
        } else {
            initGame();
        }
    }

    // Remplacer la flèche par une icône SVG plus élégante
    function setGyroStatusActive() {
      // Icône SVG "check" stylisée, couleur néon
      const checkSvg = `<svg width="22" height="22" viewBox="0 0 22 22" style="vertical-align:middle; margin-left:4px;" xmlns="http://www.w3.org/2000/svg"><polyline points="5,12 10,17 17,6" fill="none" stroke="#00ffcc" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
      gyroStatus.innerHTML = `Gyroscope activé ${checkSvg}`;
      gyroStatus.classList.add("active");
    }

    // Ajouter cette nouvelle fonction pour initialiser le jeu
    function initGame() {
        enableGyro();
        startBtn.style.display = 'none';
        setGyroStatusActive();

        // Afficher le timer dès le début
        timerDisplay.textContent = "00:05";
        timerDisplay.style.color = "white";
        timerDisplay.style.animation = "none";

        // Démarrer le timer et les animations
        timerSeconds = 5; // 5 secondes pour chaque partie
        timerInterval = setInterval(updateTimer, 1000);
        initCageAnimations();

        // Démarrer la musique
        backgroundMusic.play();
    }

    function enableGyro() {
      window.addEventListener("deviceorientation", (event) => {
        const gamma = event.gamma || 0;
        const beta = event.beta || 0;

        velX += gamma * accelerationFactor;
        velY += beta * accelerationFactor;
      });

      updateBallPosition();
    }

    startBtn.addEventListener("click", () => {
        startGyro();
        preloadSounds();
    });

    // Précharger les sons dès que possible
    function preloadSounds() {
        // Forcer le préchargement des sons en les jouant avec volume à 0
        backgroundMusic.volume = 0;
        backgroundMusic.play().then(() => {
            backgroundMusic.pause();
            backgroundMusic.currentTime = 0;
            backgroundMusic.volume = 1;
        }).catch(e => console.log("Préchargement de la musique échoué"));

        pointSound.volume = 0;
        pointSound.play().then(() => {
            pointSound.pause();
            pointSound.currentTime = 0;
            pointSound.volume = 1;
        }).catch(e => console.log("Préchargement du son de point échoué"));

        endGameSound.volume = 0;
        endGameSound.play().then(() => {
            endGameSound.pause();
            endGameSound.currentTime = 0;
            endGameSound.volume = 1;
        }).catch(e => console.log("Préchargement du son de fin échoué"));
    }

    // Fonction pour jouer le son de fin avec plusieurs tentatives
    function playEndGameSound() {
        // Première tentative immédiate
        endGameSound.play().catch(error => {
            console.log("Première tentative échouée, nouvelle tentative dans 300ms");
            
            // Deuxième tentative après un délai
            setTimeout(() => {
                endGameSound.play().catch(error => {
                    console.log("Deuxième tentative échouée, dernière tentative dans 500ms");
                    
                    // Dernière tentative avec un délai plus long
                    setTimeout(() => {
                        endGameSound.play().catch(e => {
                            console.log("Toutes les tentatives ont échoué, ajout d'un bouton son");
                            
                            // Ajout d'un bouton spécial pour jouer le son
                            const soundBtn = document.createElement("button");
                            soundBtn.textContent = "🔊 Écouter le son de fin";
                            soundBtn.style.position = "absolute";
                            soundBtn.style.top = "10px";
                            soundBtn.style.left = "50%";
                            soundBtn.style.transform = "translateX(-50%)";
                            soundBtn.style.zIndex = "2000";
                            soundBtn.style.padding = "8px 16px";
                            soundBtn.style.backgroundColor = "#00ffcc";
                            soundBtn.style.color = "#111";
                            soundBtn.style.border = "none";
                            soundBtn.style.borderRadius = "8px";
                            soundBtn.style.fontWeight = "bold";
                            soundBtn.style.cursor = "pointer";
                            
                            soundBtn.addEventListener("click", () => {
                                endGameSound.play();
                                soundBtn.remove();
                            });
                            
                            document.querySelector(".score-container").appendChild(soundBtn);
                        });
                    }, 500);
                });
            }, 300);
        });
    }

    // Fonction pour mettre à jour le timer
    function updateTimer() {
        if (timerSeconds <= 0) {
            endGame();
            return;
        }

        timerSeconds--;
        const minutes = Math.floor(timerSeconds / 60);
        const seconds = timerSeconds % 60;
        timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

        if (timerSeconds <= 30) {
            timerDisplay.style.color = "#FF0000";
            if (timerSeconds <= 10) {
                timerDisplay.style.animation = "blink 0.5s infinite alternate";
            }
        }
    }

    function endGame() {
        clearInterval(timerInterval);
        gameActive = false;
        
        // 1. Animation de disparition des cages
        const cages = document.querySelectorAll('.cage');
        cages.forEach((cage, index) => {
            setTimeout(() => {
                cage.style.transition = "opacity 0.5s ease-out, transform 0.5s ease-out";
                cage.style.opacity = "0";
                cage.style.transform = "scale(0.8)";
            }, index * 50); // Délai progressif pour effet en cascade
        });
        
        // 2. Animation de disparition des coins des cages
        const corners = document.querySelectorAll('.cage-corner');
        corners.forEach((corner, index) => {
            setTimeout(() => {
                corner.style.transition = "opacity 0.5s ease-out";
                corner.style.opacity = "0";
            }, index * 30); // Délai plus court pour les coins
        });
        
        backgroundMusic.pause();
        backgroundMusic.currentTime = 0;
        
        // Préparer l'affichage du score
        finalScoreValue.textContent = score;
        
        // Attendre que les animations de disparition soient terminées avant d'afficher le score
        setTimeout(() => {
            // Afficher l'overlay du score après la disparition des cages
            scoreOverlay.classList.add("active");
            
            // Attendre que l'overlay soit visible avant de jouer le son (délai de 800ms)
            setTimeout(() => {
                playEndGameSound();
            }, 800);
        }, 700); // Délai pour laisser le temps aux animations de disparition de se terminer
        
        // Réinitialiser le jeu
        score = 0;
        updateScoreDisplay();
        timerSeconds = 5; // Remettre à 5 secondes pour la prochaine partie
        timerDisplay.textContent = "00:05";
        timerDisplay.style.color = "white";
        timerDisplay.style.animation = "none";
        
        // Indiquer que c'est le jeu de la page 1 qui est terminé
        localStorage.setItem("game-page", "page1");
        localStorage.setItem("game-state", "finished");
    }
  </script>
</body>
</html>