<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<title>Modèle 3D sans fond</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<!-- Import de la librairie <model-viewer> -->
<script type="module" src="https://unpkg.com/@google/model-viewer/dist/model-viewer.min.js"></script>
<style>
body {
  margin: 0;
  background-color: #0b042d;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
  flex-direction: column;
}
model-viewer {
  width: 100%;
  max-width: 800px;
  height: 600px;
  background: transparent;
}
.info-row {
  display: flex;
  justify-content: center;
  align-items: center;
  gap: 24px;
  margin-bottom: 32px;
  width: 100%;
  max-width: 800px;
}
.info-rect {
  flex: 1 1 0;
  min-width: 120px;
  background: rgba(255,255,255,0.13);
  color: #f5f6fa;
  border-radius: 18px;
  padding: 20px 14px;
  font-size: 1.13rem;
  font-weight: 600;
  text-align: center;
  box-shadow: 0 4px 18px rgba(11,4,45,0.10), 0 1.5px 6px rgba(0,0,0,0.09);
  border: 1.5px solid rgba(255,255,255,0.18);
  min-height: 54px;
  display: flex;
  align-items: center;
  justify-content: center;
  letter-spacing: 0.01em;
  transition: background 0.2s, box-shadow 0.2s, color 0.2s;
  backdrop-filter: blur(2px);
}
.info-rect:not(:empty):hover {
  background: rgba(255,255,255,0.22);
  color: #0b042d;
  box-shadow: 0 6px 24px rgba(11,4,45,0.18);
  cursor: pointer;
}
.info-rect:empty {
  background: rgba(255,255,255,0.07);
  border-style: dashed;
  border-color: rgba(255,255,255,0.13);
  cursor: default;
  pointer-events: none;
}
</style>
</head>
<body>
<div class="info-row">
  <div class="info-rect" id="distanceInfo">marche en cours: 0km</div>
  <div class="info-rect" id="timeInfo">temps restant: 0 minutes</div>
  <div class="info-rect" id="speedInfo">vitesse: 0 km/h</div>
  <div class="info-rect" id="statusInfo">en attente...</div>
</div>
<!-- Modèle 3D sans fond blanc -->
<model-viewer
  id="modelViewer"
  src="GLB/final.glb"
  alt="Modèle 3D interactif"
  auto-rotate
  camera-controls
  disable-zoom>
</model-viewer>

<script>
  // Éléments d'interface
  const modelViewer = document.getElementById('modelViewer');
  const distanceInfo = document.getElementById('distanceInfo');
  const timeInfo = document.getElementById('timeInfo');
  const speedInfo = document.getElementById('speedInfo');
  const statusInfo = document.getElementById('statusInfo');
  
  // Variables pour suivre la position et le mouvement
  let watchId;
  let startPosition = null;
  let lastPosition = null;
  let totalDistance = 0;
  let currentSpeed = 0;
  let isTracking = false;
  let startTime = null;
  let estimatedTime = 9; // Temps estimé en minutes (par défaut)
  const targetDistance = 8; // Distance cible en km
  
  // Constantes pour le contrôle de la rotation
  const MIN_ROTATION_SPEED = 0.1; // Vitesse minimale de rotation (tours par minute)
  const MAX_ROTATION_SPEED = 2.0; // Vitesse maximale de rotation (tours par minute)
  const MIN_WALKING_SPEED = 0.5; // Vitesse de marche minimale (km/h)
  const MAX_WALKING_SPEED = 8.0; // Vitesse de marche maximale (km/h)
  
  // Fonction pour calculer la distance entre deux points GPS
  function calculateDistance(lat1, lon1, lat2, lon2) {
    const R = 6371; // Rayon de la Terre en km
    const dLat = (lat2 - lat1) * Math.PI / 180;
    const dLon = (lon2 - lon1) * Math.PI / 180;
    const a = 
      Math.sin(dLat/2) * Math.sin(dLat/2) +
      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
      Math.sin(dLon/2) * Math.sin(dLon/2);
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
    return R * c;
  }
  
  // Ajuster la vitesse de rotation du modèle en fonction de la vitesse de marche
  function updateModelRotation(speed) {
    // Limiter la vitesse entre les valeurs min et max
    const limitedSpeed = Math.max(MIN_WALKING_SPEED, Math.min(MAX_WALKING_SPEED, speed));
    
    // Calculer la vitesse de rotation proportionnelle
    const factor = (limitedSpeed - MIN_WALKING_SPEED) / (MAX_WALKING_SPEED - MIN_WALKING_SPEED);
    const rotationSpeed = MIN_ROTATION_SPEED + factor * (MAX_ROTATION_SPEED - MIN_ROTATION_SPEED);
    
    // Convertir tours par minute en degrés par seconde
    const rotationDegPerSec = rotationSpeed * 360 / 60;
    
    // Appliquer la rotation au modèle 3D
    modelViewer.setAttribute('rotation-per-second', `${rotationDegPerSec}deg`);
    
    // Mise à jour de l'affichage de la vitesse
    speedInfo.textContent = `vitesse: ${speed.toFixed(1)} km/h`;
  }
  
  // Mise à jour de l'interface
  function updateUI() {
    distanceInfo.textContent = `marche en cours: ${totalDistance.toFixed(2)}km`;
    
    // Calcul du temps restant estimé
    if (currentSpeed > 0) {
      const remainingDistance = targetDistance - totalDistance;
      if (remainingDistance > 0) {
        const remainingTimeHours = remainingDistance / currentSpeed;
        const remainingTimeMinutes = Math.ceil(remainingTimeHours * 60);
        timeInfo.textContent = `temps restant: ${remainingTimeMinutes} minutes`;
        estimatedTime = remainingTimeMinutes;
      } else {
        timeInfo.textContent = `temps restant: 0 minutes`;
      }
    } else {
      timeInfo.textContent = `temps restant: ${estimatedTime} minutes`;
    }
  }
  
  // Gestionnaire de position GPS
  function handlePosition(position) {
    const { latitude, longitude } = position.coords;
    const currentTime = new Date().getTime();
    
    if (!startPosition) {
      startPosition = { latitude, longitude };
      lastPosition = { latitude, longitude };
      startTime = currentTime;
      statusInfo.textContent = "en mouvement";
      return;
    }
    
    // Calcul de la distance entre la dernière position et la position actuelle
    const segmentDistance = calculateDistance(
      lastPosition.latitude, lastPosition.longitude,
      latitude, longitude
    );
    
    // Filtrer les mises à jour trop petites (réduire les erreurs GPS)
    if (segmentDistance < 0.001) {
      return;
    }
    
    // Mise à jour de la distance totale
    totalDistance += segmentDistance;
    
    // Calcul de la vitesse (km/h)
    if (lastPosition && lastPosition.time) {
      const timeDiff = (currentTime - lastPosition.time) / 1000 / 3600; // en heures
      if (timeDiff > 0) {
        currentSpeed = segmentDistance / timeDiff;
        updateModelRotation(currentSpeed);
      }
    }
    
    // Mise à jour de la dernière position
    lastPosition = { latitude, longitude, time: currentTime };
    
    // Mise à jour de l'interface
    updateUI();
  }
  
  // Gérer les erreurs de géolocalisation
  function handleError(error) {
    switch(error.code) {
      case error.PERMISSION_DENIED:
        statusInfo.textContent = "Accès GPS refusé";
        break;
      case error.POSITION_UNAVAILABLE:
        statusInfo.textContent = "Position indisponible";
        break;
      case error.TIMEOUT:
        statusInfo.textContent = "Délai expiré";
        break;
      default:
        statusInfo.textContent = "Erreur inconnue";
    }
  }
  
  // Démarrer le suivi de position
  function startTracking() {
    if (!isTracking && navigator.geolocation) {
      // Options pour la géolocalisation
      const options = {
        enableHighAccuracy: true, // Haute précision pour une meilleure mesure
        maximumAge: 0,            // Ne pas utiliser de cache
        timeout: 5000             // Délai d'attente en ms
      };
      
      // Démarrer le suivi GPS
      watchId = navigator.geolocation.watchPosition(handlePosition, handleError, options);
      isTracking = true;
      statusInfo.textContent = "démarrage...";
      
      // Définir une rotation par défaut en attendant le mouvement
      modelViewer.setAttribute('auto-rotate', true);
      modelViewer.setAttribute('rotation-per-second', `${MIN_ROTATION_SPEED * 360 / 60}deg`);
    } else {
      statusInfo.textContent = "GPS non disponible";
    }
  }
  
  // Arrêter le suivi de position
  function stopTracking() {
    if (isTracking) {
      navigator.geolocation.clearWatch(watchId);
      isTracking = false;
      statusInfo.textContent = "arrêté";
    }
  }
  
  // Démarrer le suivi au chargement de la page
  document.addEventListener('DOMContentLoaded', startTracking);
  
  // Ajouter des événements pour les rectangles d'info
  statusInfo.addEventListener('click', function() {
    if (isTracking) {
      stopTracking();
    } else {
      startTracking();
    }
  });
</script>
</body>
</html>