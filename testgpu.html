<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Grille + rectangle central avec CGU</title>
<style>
@font-face {
  font-family: 'AMORIA';
  src: url('AMORIA.otf') format('opentype');
  font-weight: normal;
  font-style: normal;
}
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden !important;
  background: #111;
  /* Empêche le scroll sur mobile */
  touch-action: none;
}
body {
  width: 100vw;
  height: 100vh;
  position: relative;
  overflow: hidden !important;
}
#canvas {
  position: absolute;
  inset: 0;
  width: 100vw;
  height: 100vh;
  z-index: 0;
  display: block;
}
.center-rect {
  position: absolute;
  left: 50%;
  top: 50%;
  width: 320px;
  height: 260px;
  background: rgba(0,0,0,0.7);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 8px;
  transform: translate(-50%, -50%);
  z-index: 2;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  padding: 10px 16px;
  box-sizing: border-box;
  /* Police par défaut plus lisible */
  font-family: 'Inter', Arial, sans-serif;
  color: #fff;
  overflow: hidden;
}

.center-rect h1 {
  font-family: 'AMORIA', serif;
  font-size: 2.2em;
  margin-bottom: 15px;
  margin-top: 5px;
  letter-spacing: 0.04em;
  text-align: center;
}

.center-rect h2 {
  font-size: 1.1em;
  margin-top: 10px;
  margin-bottom: 8px;
  font-family: 'Inter', Arial, sans-serif;
  font-weight: 600;
}

.center-rect p {
  font-size: 0.92em;
  text-align: center;
  margin: 8px 0;
  line-height: 1.5;
  font-family: 'Inter', Arial, sans-serif;
}

#cgu-buttons {
  display: flex;
  gap: 10px;
  margin-top: 15px;
}

.cgu-button {
  background: rgba(255,255,255,0.15);
  color: #fff;
  border: 1px solid rgba(255,255,255,0.3);
  border-radius: 4px;
  padding: 8px 15px;
  font-family: 'Inter', Arial, sans-serif;
  font-size: 0.95em;
  cursor: pointer;
  transition: all 0.2s ease;
}

.cgu-button:hover {
  background: rgba(255,255,255,0.25);
}

@media (max-width: 600px) {
  .center-rect {
    width: 75vw;
    max-width: 85vw;
    height: auto;
    min-height: 120px;
    padding: 8px 10px;
  }
  
  .center-rect h1 {
    font-size: 1.2em;
    margin-bottom: 8px;
  }
  
  .center-rect h2 {
    font-size: 0.8em;
    margin-top: 6px;
    margin-bottom: 4px;
  }
  
  .center-rect p {
    font-size: 0.7em;
    line-height: 1.2;
  }
  
  .cgu-button {
    font-size: 0.75em;
    padding: 5px 10px;
  }
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div class="center-rect">
  <h1>Chroméa</h1>
  <h2>Conditions Générales d'Utilisation</h2>
  <p>En accédant à cette animation, vous acceptez les conditions suivantes :<br>
   Il s'agit d'une expérience visuelle générative à titre expérimental.<br>
   Aucune donnée personnelle n'est collectée.</p>
  <div id="cgu-buttons">
    <button class="cgu-button" onclick="acceptCGU()">Accepter</button>
    <button class="cgu-button" onclick="refuseCGU()">Refuser</button>
  </div>
</div>

<script>
// Fonction pour gérer l'acceptation des CGU
function acceptCGU() {
  const centerRect = document.querySelector('.center-rect');
  centerRect.innerHTML = '<h1>Chroméa</h1>';
  centerRect.style.height = '180px';
  centerRect.style.background = 'rgba(0,0,0,0)';
  centerRect.style.border = '0';
}

// Fonction pour gérer le refus des CGU
function refuseCGU() {
  alert("Vous devez accepter les CGU pour accéder à l'expérience.");
}

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
// Configuration responsive
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
// Ajuster la taille des cercles en fonction du dispositif
const baseRadius = isMobile ? 16 : 22; // Agrandir les ronds
let radius = baseRadius;
let diameter = radius * 2;
const colors = ["#00A993", "#E68B4A", "#7A1619", "#362777", "#EB7AAE",
"#0069AA", "#DC0C15", "#E03A8D", "#FFFFFF", "#2A4899"];
const gradientMap = {
  "#00A993": "#E68B4A", "#E68B4A": "#7A1619", "#7A1619": "#362777",
  "#362777": "#EB7AAE", "#EB7AAE": "#0069AA", "#0069AA": "#DC0C15",
  "#DC0C15": "#E03A8D", "#E03A8D": "#FFFFFF", "#FFFFFF": "#2A4899",
  "#2A4899": "#00A993"
};
let colorGrid = [];
let appearingZones = []; // Liste des zones de cercles à afficher progressivement
let currentZoneIndex = 0; // Index de la zone actuellement en cours d'apparition
let currentCircleIndex = 0; // Index du cercle actuellement en cours d'apparition

function resizeCanvas() {
  const dpr = window.devicePixelRatio || 1; // Récupérer le ratio de pixels de l'appareil
  canvas.width = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;
  canvas.style.width = `${window.innerWidth}px`;
  canvas.style.height = `${window.innerHeight}px`;
  ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform avant scale
  ctx.scale(dpr, dpr); // Adapter le contexte au ratio de pixels

  // Ajuster dynamiquement le rayon en fonction de la taille de l'écran
  if (isMobile) {
    const desiredCirclesWidth = window.innerWidth < 380 ? 12 : 15;
    radius = Math.min(16, Math.floor(window.innerWidth / desiredCirclesWidth / 2));
  } else {
    radius = baseRadius;
  }
  diameter = radius * 2;

  // Utiliser un pas de radius pour coller les cercles
  const cols = Math.ceil(window.innerWidth / radius) + 2;
  const rows = Math.ceil(window.innerHeight / radius) + 2;

  colorGrid = new Array(rows).fill().map(() => new Array(cols).fill(null));
  appearingZones = []; // Réinitialiser la liste des zones
  currentZoneIndex = 0; // Réinitialiser l'index
  currentCircleIndex = 0; // Réinitialiser l'index des cercles

  // Générer la grille et regrouper les cercles par zones de couleur
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const neighbors = getNeighborColors(x, y);
      let chosenColor;

      if (neighbors.length > 0 && Math.random() < 0.8) {
        chosenColor = neighbors[Math.floor(Math.random() * neighbors.length)];
      } else {
        chosenColor = colors[Math.floor(Math.random() * colors.length)];
      }

      colorGrid[y][x] = chosenColor;
    }
  }

  // Identifier les zones de couleur
  const visited = new Set();
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const color = colorGrid[y][x];
      if (color && !visited.has(`${x},${y}`)) {
        const zone = getZone(x, y, color, visited);
        appearingZones.push(zone);
      }
    }
  }
}

function getNeighborColors(cx, cy) {
  const neighborColors = [];
  for (let dy = -1; dy <= 0; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      const nx = cx + dx;
      const ny = cy + dy;
      if (nx >= 0 && ny >= 0 && ny < colorGrid.length && nx < colorGrid[0].length) {
        const color = colorGrid[ny][nx];
        if (color) neighborColors.push(color);
      }
    }
  }
  return neighborColors;
}

function getZone(x, y, targetColor, visited) {
  const queue = [[x, y]];
  const zone = [];

  while (queue.length > 0) {
    const [cx, cy] = queue.shift();
    const key = `${cx},${cy}`;
    if (visited.has(key)) continue;
    visited.add(key);

    if (colorGrid[cy]?.[cx] === targetColor) {
      zone.push({ x: cx, y: cy, color: targetColor });
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx !== 0 || dy !== 0) {
            queue.push([cx + dx, cy + dy]);
          }
        }
      }
    }
  }

  return zone;
}

function animate(time) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Afficher toutes les zones déjà générées
  for (let i = 0; i < currentZoneIndex; i++) {
    const zone = appearingZones[i];
    for (const { x, y, color } of zone) {
      const cx = x * radius;
      const cy = y * radius;

      const gradient = ctx.createRadialGradient(cx, cy, radius * 0.3, cx, cy, radius);
      gradient.addColorStop(0, color);
      gradient.addColorStop(1, gradientMap[color.toUpperCase()] || color);

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  // Afficher les cercles de la zone actuelle progressivement
  if (currentZoneIndex < appearingZones.length) {
    const currentZone = appearingZones[currentZoneIndex];
    for (let j = 0; j <= currentCircleIndex; j++) {
      if (j >= currentZone.length) break;

      const { x, y, color } = currentZone[j];
      const cx = x * radius;
      const cy = y * radius;

      const gradient = ctx.createRadialGradient(cx, cy, radius * 0.3, cx, cy, radius);
      gradient.addColorStop(0, color);
      gradient.addColorStop(1, gradientMap[color.toUpperCase()] || color);

      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fill();
    }

    // Passer au cercle suivant ou à la zone suivante
    if (currentCircleIndex < currentZone.length - 1) {
      setTimeout(() => {
        currentCircleIndex++;
        requestAnimationFrame(animate);
      }, 0); // Délai à 0ms pour accélérer
    } else {
      setTimeout(() => {
        currentZoneIndex++;
        currentCircleIndex = 0;
        requestAnimationFrame(animate);
      }, 0); // Délai à 0ms pour accélérer
    }
  }
}

// Fonction utilitaire pour limiter les appels de redimensionnement
function debounce(func, wait) {
  let timeout;
  return function() {
    const context = this;
    const args = arguments;
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      func.apply(context, args);
    }, wait);
  };
}

// Initialisation
window.addEventListener("load", () => {
  window.addEventListener("resize", debounce(resizeCanvas, 250));
  resizeCanvas();
  requestAnimationFrame(animate);
});
</script>
</body>
</html>