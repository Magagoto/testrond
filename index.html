<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Grille + rectangle central avec CGU</title>
<style>
@font-face {
  font-family: 'AMORIA';
  src: url('AMORIA.otf') format('opentype');
  font-weight: normal;
  font-style: normal;
}
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden !important;
  background: #07114d;
  /* Empêche le scroll sur mobile */
  touch-action: none;
  position: fixed;
  width: 100vw;
  /* Ajout pour empêcher tout scroll */
}
body {
  width: 100vw;
  height: 100vh;
  position: relative;
  overflow: hidden !important;
  /* Désactive le scroll */
  overscroll-behavior: none;
  position: fixed;
  inset: 0;
}
#canvas {
  position: absolute;
  inset: 0;
  width: 100vw;
  height: 100vh;
  z-index: 0;
  display: block;
}
.center-rect {
  position: absolute;
  left: 50%;
  top: 50%;
  width: 320px;
  height: 320px;
  background: #07114d; /* même couleur que le fond de page */
  border: 2.5px solid #fff;
  box-shadow: 0 8px 32px 0 rgba(0,0,0,0.22), 0 1.5px 16px 0 rgba(62,95,255,0.10);
  border-radius: 22px;
  transform: translate(-50%, -50%);
  z-index: 2;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  padding: 18px 18px 12px 18px;
  box-sizing: border-box;
  font-family: 'Inter', Arial, sans-serif;
  color: #fff;
  overflow: hidden; /* Désactive le scroll dans le CGU */
  backdrop-filter: blur(12px) saturate(1.3);
  transition: box-shadow 0.3s, border 0.3s, background 0.3s;
  /* Ajout animation */
  animation: cgu-pop 1.2s cubic-bezier(.22,1.15,.45,1.01);
  /* Animation continue légère */
  animation-name: cgu-pop, cgu-float;
  animation-duration: 1.2s, 4.5s;
  animation-timing-function: cubic-bezier(.22,1.15,.45,1.01), ease-in-out;
  animation-iteration-count: 1, infinite;
  animation-fill-mode: both;
}

/* Scrollbar stylisée pour le rectangle CGU */
.center-rect::-webkit-scrollbar {
  width: 6px;
  background: transparent;
}
.center-rect::-webkit-scrollbar-thumb {
  background: linear-gradient(135deg, #ff5eae 0%, #ff94d6 100%);
  border-radius: 10px;
  min-height: 28px;
  box-shadow: 0 2px 8px #ff5eae33;
  border: 1.5px solid #fff3;
}
.center-rect::-webkit-scrollbar-thumb:hover {
  background: linear-gradient(135deg, #ff94d6 0%, #ff5eae 100%);
}
.center-rect::-webkit-scrollbar-track {
  background: #07114d;
  border-radius: 10px;
}
.center-rect {
  scrollbar-width: thin;
  scrollbar-color: #ff5eae #07114d;
}

.center-rect h1 {
  font-family: 'AMORIA', serif;
  font-size: 1.3em; /* réduit */
  margin-bottom: 10px;
  margin-top: 2px;
  letter-spacing: 0.08em;
  text-align: center;
  color: #fff;
  text-shadow: 0 2px 12px #0006, 0 1px 0 #fff2;
  font-weight: 700;
  /* plus de chrome, style sobre et élégant */
}

.center-rect h2 {
  font-size: 0.95em; /* réduit */
  margin-top: 10px;
  margin-bottom: 12px;
  font-family: 'Inter', Arial, sans-serif;
  font-weight: 700;
  color: #fff;
  letter-spacing: 0.04em;
  text-shadow: 0 1px 8px #0002;
  border-bottom: 1.5px solid #fff2;
  padding-bottom: 6px;
  width: 100%;
  text-align: center;
}

.center-rect p {
  font-size: 1em;
  text-align: center;
  margin: 12px 0 8px 0;
  line-height: 1.6;
  font-family: 'Inter', Arial, sans-serif;
  color: #e3e8ff;
  text-shadow: 0 1px 8px #0002;
}

#cgu-buttons {
  display: flex;
  gap: 18px;
  margin-top: 20px;
}

.cgu-button {
  background: #fff;
  color: #222b4d;
  border: none;
  border-radius: 7px;
  padding: 10px 26px;
  font-family: 'Inter', Arial, sans-serif;
  font-size: 1em;
  font-weight: 700;
  cursor: pointer;
  box-shadow: 0 2px 8px 0 #0002;
  transition: background 0.2s, box-shadow 0.2s, transform 0.15s, color 0.2s, filter 0.2s;
  outline: none;
  /* Animation d'apparition */
  animation: cgu-btn-pop 0.7s cubic-bezier(.22,1.15,.45,1.01);
  /* Animation continue légère */
  animation-name: cgu-btn-pop, cgu-btn-float;
  animation-duration: 0.7s, 3.2s;
  animation-timing-function: cubic-bezier(.22,1.15,.45,1.01), ease-in-out;
  animation-iteration-count: 1, infinite;
  animation-fill-mode: both;
}

@keyframes cgu-btn-pop {
  0% {
    opacity: 0;
    transform: scale(0.7) translateY(18px);
    filter: blur(2px);
  }
  60% {
    opacity: 1;
    transform: scale(1.08) translateY(-4px);
    filter: blur(0.5px);
  }
  80% {
    transform: scale(0.97) translateY(2px);
  }
  100% {
    opacity: 1;
    transform: scale(1) translateY(0);
    filter: blur(0);
  }
}

@keyframes cgu-btn-float {
  0%   { transform: scale(1) translateY(0);}
  20%  { transform: scale(1.01) translateY(-2px);}
  40%  { transform: scale(0.99) translateY(2px);}
  60%  { transform: scale(1.01) translateY(-1px);}
  80%  { transform: scale(1) translateY(1px);}
  100% { transform: scale(1) translateY(0);}
}

@keyframes cgu-pop {
  0% {
    opacity: 0;
    transform: translate(-50%, -50%) scale(0.7) rotate(-8deg);
    box-shadow: 0 0 0 0 #0000;
  }
  60% {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1.05) rotate(2deg);
    box-shadow: 0 12px 40px 0 #0004;
  }
  80% {
    transform: translate(-50%, -50%) scale(0.97) rotate(-1deg);
  }
  100% {
    opacity: 1;
    transform: translate(-50%, -50%) scale(1) rotate(0deg);
    box-shadow: 0 8px 32px 0 rgba(0,0,0,0.22), 0 1.5px 16px 0 rgba(62,95,255,0.10);
  }
}

@keyframes cgu-float {
  0%   { transform: translate(-50%, -50%) scale(1) rotate(0deg);}
  20%  { transform: translate(-50%, -51%) scale(1.01) rotate(-1deg);}
  40%  { transform: translate(-50%, -49%) scale(0.99) rotate(1deg);}
  60%  { transform: translate(-50%, -50%) scale(1.01) rotate(-0.5deg);}
  80%  { transform: translate(-50%, -51%) scale(1) rotate(0.5deg);}
  100% { transform: translate(-50%, -50%) scale(1) rotate(0deg);}
}

@media (max-width: 600px) {
  .center-rect {
    width: 80vw;
    max-width: 90vw;
    height: 70vw;
    max-height: 75vw;
    min-height: 100px;
    padding: 6px 2vw 4px 2vw;
    border-radius: 14px;
    /* Ajout pour remonter le cadre sur mobile */
    top: 48%;
    transform: translate(-50%, -48%);
  }
  .center-rect h1 {
    font-size: 1em;
    margin-bottom: 7px;
  }
  .center-rect h2 {
    font-size: 0.8em;
    margin-top: 4px;
    margin-bottom: 6px;
    padding-bottom: 3px;
  }
  .center-rect p {
    font-size: 0.8em;
    line-height: 1.3;
  }
  .cgu-button {
    font-size: 0.85em;
    padding: 7px 12px;
  }
  #cgu-buttons {
    gap: 8px;
    margin-top: 10px;
  }
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<audio id="backgroundMusic" src="SONORE/ambiance page principale.mp3" loop preload="auto" autoplay></audio>
<div class="center-rect">
  <h1>Chroméa</h1>
  <h2>Conditions Générales de Jeu (CGJ)</h2>
  <div id="cgu-content" style="text-align:left; font-size:0.85em; line-height:1.5; max-height:48vh; overflow:auto; width:100%; box-sizing:border-box;">
    <b>Version 1.0.1 – Mise à jour effective à compter du 05 mai 2025</b><br>
    <b>Désignation du dispositif expérientiel :</b> (titre en attente de validation métaphorique)
    <br>
    <b>Préambule élargi et étendu</b><br>
    Les présentes Conditions Générales de Jeu (ci-après désignées sous l'acronyme volontairement opaque « CGJ »), rédigées en vertu des principes fondateurs de droit contractuel simulé, de normes supranationales implicites, d’arrêts fictifs rendus par des juridictions expérimentales, et de recommandations non contraignantes de structures consultatives désaffectées, ont pour objet de constituer un socle textuel, mouvant, extensible et partiellement incompréhensible, destiné à régir, orienter, encadrer, détourner, retarder ou obstruer l’accès, la participation, la navigation et l’activation sensorielle du Joueur dans le cadre du dispositif interactif transréel (le « Jeu »), sans que la compréhension effective des présentes ne constitue une condition préalable ou suffisante d’adhésion.<br>
    <br>
    Il est entendu que le seul fait d'accéder, même passivement, à l’interface logicielle ou physique du Jeu, que ce soit par action volontaire, impulsion mimétique, suggestion algorithmique ou simple effet d'inertie de navigation, vaut acceptation intégrale, irrévocable, non rétractable et sans réserve des présentes CGJ, y compris dans leurs versions ultérieures, antérieures, conjecturées ou alternativement valides dans un univers interprétatif parallèle.
    <br><br>
    <b>Article 1 – Étendue fluctuante et applicabilité contextuelle</b><br>
    Les présentes CGJ s’appliquent à tout Joueur, entité physique, morale, fictive, incarnée, simulée ou spéculaire, accédant de manière directe, indirecte, analogique ou intuitive, au Jeu, et ce, indépendamment de la conscience qu’il pourrait avoir de sa participation ou de la nature ludique, contractuelle ou performative de l’expérience. L’extension territoriale, temporelle, juridictionnelle ou narrative de ces CGJ est illimitée, indéfinissable et sujette à révision spontanée sans avertissement, publication préalable ou logique prévisible.<br>
    <br>
    Le présent texte peut également s'appliquer rétroactivement à des interactions précédant son existence, à des individus n'ayant pas manifesté leur consentement explicite, ainsi qu’à toute structure cognitive susceptible d’être influencée par une exposition fortuite aux éléments constitutifs du Jeu.
    <br><br>
    <b>Article 2 – Conditions technico-sensorimotrices d’accès élargi</b><br>
    L’accès au Jeu, dans sa forme numérique, topographique ou poético-fonctionnelle, suppose l’utilisation exclusive, ou simultanée, de dispositifs de traitement de données mobiles conformes ou non aux standards en vigueur, lesquels incluent, à titre non limitatif : un terminal d’interface réseau disposant d’un navigateur acceptant l’exécution de scripts dynamiques, un module de géolocalisation persistante, une capacité de mémoire vive supérieure à celle du seuil d’épuisement narratif, et une permissivité explicite aux déclenchements sensoriels spatio-temporels sans interruption.<br>
    <br>
    Aucune compatibilité descendante n’est assurée, et la tolérance aux disjonctions techniques, logiques ou métaphysiques est laissée à l’entière discrétion du Joueur, qui en assume la pleine responsabilité sans pouvoir invoquer le trouble technologique ou la surcharge interprétative comme cause d’interruption contractuelle.
    <br><br>
    <b>Article 3 – Acceptation implicite, inconditionnelle et auto-référentielle</b><br>
    Le Joueur reconnaît, par l'effet même de son exposition à l'environnement du Jeu, avoir pris connaissance, compris et accepté dans leur intégralité les CGJ, y compris les passages volontairement ambigus, les clauses tautologiques, les contradictions internes et les énoncés susceptibles de générer des interprétations multiples, divergentes ou contradictoires. Il s’engage, en outre, à ne formuler aucune réclamation fondée sur l’illisibilité, la densité lexicale, la complexité grammaticale ou la prolixité rhétorique des présentes.<br>
    <br>
    L’acceptation inclut également tous les mécanismes de consentement futurs, les avenants implicites, les protocoles dérivés, les actes de langage performatifs, ainsi que les silences interprétés comme des signes de reconnaissance contractuelle par le système.
    <br><br>
    <b>Article 4 – Mécanismes de participation volontairement ambigus</b><br>
    La participation au Jeu consiste en l’accomplissement de déplacements, actions, attentes, renoncements, déclics ou hésitations sur des points géographiquement codés, mais métaphoriquement instables, appelés Points de Raffinage (PR), Points de Connexion Subtile (PCS) ou Nœuds d’Activation Rituelle (NAR), selon la taxinomie provisoire en vigueur.<br>
    <br>
    Ces Points peuvent être :
    <ul style="margin-top:0;margin-bottom:0.5em;">
      <li>visibles ou invisibles, selon l’état d’attention du Joueur,</li>
      <li>accessibles ou inaccessibles, en fonction d’itérations aléatoires,</li>
      <li>actifs ou latents, selon des règles hermétiques non divulguées.</li>
    </ul>
    L’activation d’un point ne garantit aucun retour d’information, aucune progression linéaire, ni aucune transformation mesurable du système de jeu, mais peut entraîner une modification interne, cognitive ou contextuelle du Joueur sans avertissement ni réversibilité.
    <br><br>
    <b>Article 5 – Clause de non-responsabilité à extension multidimensionnelle</b><br>
    L’Éditeur, ses filiales réelles ou hypothétiques, les agents intermédiaires, les régies technologiques dissoutes, les collectifs mythopoétiques associés et les entités autonomes auto-émergentes déclinent toute forme de responsabilité en cas de :
    <ul style="margin-top:0;margin-bottom:0.5em;">
      <li>modification imprévue de l’état mental ou émotionnel du Joueur,</li>
      <li>reconfiguration symbolique des espaces publics visités,</li>
      <li>surgissement d’interprétations narratives incontrôlées,</li>
      <li>confusion entre expérience vécue et construction fictionnelle,</li>
      <li>dommages immatériels dus à un excès de sens ou à un déficit de signification.</li>
    </ul>
    Cette clause couvre également les effets différés, les hallucinations localisées, les anomalies rituelles ou tout état de dérive perceptive survenant après la cessation effective du Jeu.
    <br><br>
    <b>Article 6 – Données collectées, interprétées, absorbées</b><br>
    Le Joueur consent, de manière libre et sans ambiguïté apparente, à la collecte, à l’agrégation, au traitement, à l’abstraction et à la potentialisation de données personnelles, comportementales, psychogéographiques, narratives ou émotionnelles, à des fins non spécifiées, dans le cadre d’un traitement automatique, symbolique ou ritualisé, susceptible d’influencer à terme la structure ontologique de son identité ludique.<br>
    <br>
    Parmi les données susceptibles d’être enregistrées (à titre non exhaustif) figurent :
    <ul style="margin-top:0;margin-bottom:0.5em;">
      <li>les coordonnées GPS temps réel multi-échelle,</li>
      <li>les micro-temps de latence décisionnelle,</li>
      <li>les fréquences de réorientation corporelle,</li>
      <li>les vecteurs de doute narratif,</li>
      <li>les résidus cognitifs en fin de session.</li>
    </ul>
    <b>Article 7 – Clause de modification continue, non avertie</b><br>
    Les CGJ peuvent être mises à jour, réécrites, étendues, compressées, transposées ou annulées à tout moment, sans consultation, notification, validation ni publication. Toute consultation, utilisation, visualisation ou simple pensée liée au Jeu postérieure à une modification, constitue une acceptation implicite de la version la plus récente, même si celle-ci demeure inédite, inaccessible ou contradictoire avec la précédente.
    <br><br>
    <b>Article 8 – Droit applicable et juridictions dérivées</b><br>
    Les présentes CGJ relèvent d’un droit hybride, constitué d’un entrelacs de principes coutumiers locaux, de jurisprudences spéculatives, de fragments de lois désaffectées, de concepts éthérés issus de fictions juridiques expérimentales, et de mécanismes d’arbitrage intérieur subjectif. En cas de litige, conflit, mésentente ou dissociation symbolique, aucune juridiction ne sera compétente, sauf celle que le Joueur décidera d’inventer, convoquer ou incarner dans un moment d’introspection formelle.
  </div>
  <div id="cgu-buttons">
    <button class="cgu-button" onclick="acceptCGU()">Accepter</button>
    <button class="cgu-button" onclick="refuseCGU()">Refuser</button>
  </div>
</div>
<!-- Vérification : il n'y a qu'un seul rectangle central (center-rect) affiché.
Aucun autre rectangle ou div superposée n'est présent dans le HTML. 
Si tu vois un rectangle en dessous, il s'agit probablement d'un effet visuel du canvas ou du CSS (ombre portée, etc.).
Aucune modification n'est nécessaire pour supprimer un rectangle supplémentaire, car il n'y en a pas dans le code. -->

<script>
// Fonction pour gérer l'acceptation des CGU
let cguFullyScrolled = false;

// Vérifie si l'utilisateur a scrollé jusqu'en bas du CGU
document.addEventListener("DOMContentLoaded", function() {
  const cguContent = document.getElementById('cgu-content');
  if (!cguContent) return;
  cguContent.addEventListener('scroll', function() {
    // Tolérance de 2px pour le scroll
    if (cguContent.scrollTop + cguContent.clientHeight >= cguContent.scrollHeight - 2) {
      cguFullyScrolled = true;
    }
  });
});

function acceptCGU() {
  if (!cguFullyScrolled) {
    alert("Veuillez lire l'intégralité des conditions générales avant d'accepter.");
    return;
  }
  window.location.href = "jeu.html";
  // document.getElementById('backgroundMusic').play();
}

function refuseCGU() {
  alert("Vous devez accepter les CGU pour accéder à l'expérience.");
}

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
// Configuration responsive
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
// Ajuster la taille des cercles en fonction du dispositif
const baseRadius = isMobile ? 16 : 22; // Agrandir les ronds
let radius = baseRadius;
let diameter = radius * 2;
const colors = ["#00A993", "#E68B4A", "#7A1619", "#362777", "#EB7AAE",
"#0069AA", "#DC0C15", "#E03A8D", "#FFFFFF", "#2A4899"];
const gradientMap = {
  "#00A993": "#E68B4A", "#E68B4A": "#7A1619", "#7A1619": "#362777",
  "#362777": "#EB7AAE", "#EB7AAE": "#0069AA", "#0069AA": "#DC0C15",
  "#DC0C15": "#E03A8D", "#E03A8D": "#FFFFFF", "#FFFFFF": "#2A4899",
  "#2A4899": "#00A993"
};
let colorGrid = [];
let appearingZones = []; // Liste des zones de cercles à afficher progressivement
let currentZoneIndexTop = 0;
let currentZoneIndexBottom = 0;
let currentCircleIndexTop = 0;
let currentCircleIndexBottom = 0;

// --- Ajout pour les dégradés linéaires animés ---
let linearGradientZones = new Map();

function chooseLinearGradientZones() {
  linearGradientZones.clear();
  // 1 zone sur 3 en dégradé linéaire animé
  let zoneIndex = 0;
  const totalZones = appearingZones.length;
  for (let i = 0; i < totalZones; i++) {
    if (i % 3 === 0) {
      const zone = appearingZones[i];
      if (!zone || zone.length < 2) continue;
      const baseAngle = Math.random() * 2 * Math.PI;
      const phaseOffset = Math.random() * Math.PI * 2;
      const animationSpeed = 0.5 + Math.random() * 1.5;
      const oscillationAmount = Math.PI / 4 + Math.random() * Math.PI / 4;
      for (const {x, y} of zone) {
        const key = `${x},${y}`;
        linearGradientZones.set(key, {
          baseAngle,
          phaseOffset,
          animationSpeed,
          oscillationAmount
        });
      }
    }
  }
}

function resizeCanvas() {
  const dpr = window.devicePixelRatio || 1; // Récupérer le ratio de pixels de l'appareil
  canvas.width = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;
  canvas.style.width = `${window.innerWidth}px`;
  canvas.style.height = `${window.innerHeight}px`;
  ctx.setTransform(1, 0, 0, 1, 0, 0); // Reset transform avant scale
  ctx.scale(dpr, dpr); // Adapter le contexte au ratio de pixels

  // Ajuster dynamiquement le rayon en fonction de la taille de l'écran
  if (isMobile) {
    const desiredCirclesWidth = window.innerWidth < 380 ? 12 : 15;
    radius = Math.min(16, Math.floor(window.innerWidth / desiredCirclesWidth / 2));
  } else {
    radius = baseRadius;
  }
  diameter = radius * 2;

  // Utiliser un pas de radius pour coller les cercles
  const cols = Math.ceil(window.innerWidth / radius) + 2;
  const rows = Math.ceil(window.innerHeight / radius) + 2;

  colorGrid = new Array(rows).fill().map(() => new Array(cols).fill(null));
  appearingZones = []; // Réinitialiser la liste des zones
  currentZoneIndexTop = 0;
  currentZoneIndexBottom = 0;
  currentCircleIndexTop = 0;
  currentCircleIndexBottom = 0;

  // Générer la grille et regrouper les cercles par zones de couleur
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const neighbors = getNeighborColors(x, y);
      let chosenColor;

      if (neighbors.length > 0 && Math.random() < 0.8) {
        chosenColor = neighbors[Math.floor(Math.random() * neighbors.length)];
      } else {
        chosenColor = colors[Math.floor(Math.random() * colors.length)];
      }

      colorGrid[y][x] = chosenColor;
    }
  }

  // Identifier les zones de couleur
  const visited = new Set();
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const color = colorGrid[y][x];
      if (color && !visited.has(`${x},${y}`)) {
        const zone = getZone(x, y, color, visited);
        appearingZones.push(zone);
      }
    }
  }

  chooseLinearGradientZones(); // Ajout ici
}

function getNeighborColors(cx, cy) {
  const neighborColors = [];
  for (let dy = -1; dy <= 0; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      const nx = cx + dx;
      const ny = cy + dy;
      if (nx >= 0 && ny >= 0 && ny < colorGrid.length && nx < colorGrid[0].length) {
        const color = colorGrid[ny][nx];
        if (color) neighborColors.push(color);
      }
    }
  }
  return neighborColors;
}

function getZone(x, y, targetColor, visited) {
  const queue = [[x, y]];
  const zone = [];

  while (queue.length > 0) {
    const [cx, cy] = queue.shift();
    const key = `${cx},${cy}`;
    if (visited.has(key)) continue;
    visited.add(key);

    if (colorGrid[cy]?.[cx] === targetColor) {
      zone.push({ x: cx, y: cy, color: targetColor });
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx !== 0 || dy !== 0) {
            queue.push([cx + dx, cy + dy]);
          }
        }
      }
    }
  }

  return zone;
}

function isInCenterRect(cx, cy) {
  // Désactivé : autorise les ronds à passer sous le GPU
  return false;
}

function animate(time) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Afficher toutes les zones déjà générées depuis le haut
  for (let i = 0; i < currentZoneIndexTop; i++) {
    const zone = appearingZones[i];
    for (const { x, y, color } of zone) {
      const cx = x * radius;
      const cy = y * radius;
      if (isInCenterRect(cx, cy)) continue;
      // --- Ajout : dégradé linéaire animé pour certaines zones ---
      const key = `${x},${y}`;
      let fillStyle;
      if (linearGradientZones.has(key)) {
        const info = linearGradientZones.get(key);
        const t = (performance.now() / 1000) * info.animationSpeed + info.phaseOffset;
        const angle = info.baseAngle + Math.sin(t) * info.oscillationAmount;
        const dx = Math.cos(angle) * radius;
        const dy = Math.sin(angle) * radius;
        const grad = ctx.createLinearGradient(cx - dx, cy - dy, cx + dx, cy + dy);
        grad.addColorStop(0, color);
        grad.addColorStop(1, gradientMap[color.toUpperCase()] || color);
        fillStyle = grad;
      } else {
        const grad = ctx.createRadialGradient(cx, cy, radius * 0.3, cx, cy, radius);
        grad.addColorStop(0, color);
        grad.addColorStop(1, gradientMap[color.toUpperCase()] || color);
        fillStyle = grad;
      }
      ctx.fillStyle = fillStyle;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fill();
    }
  }
  // Afficher toutes les zones déjà générées depuis le bas
  for (let i = 0; i < currentZoneIndexBottom; i++) {
    const zone = appearingZones[appearingZones.length - 1 - i];
    for (const { x, y, color } of zone) {
      const cx = x * radius;
      const cy = y * radius;
      if (isInCenterRect(cx, cy)) continue;
      const key = `${x},${y}`;
      let fillStyle;
      if (linearGradientZones.has(key)) {
        const info = linearGradientZones.get(key);
        const t = (performance.now() / 1000) * info.animationSpeed + info.phaseOffset;
        const angle = info.baseAngle + Math.sin(t) * info.oscillationAmount;
        const dx = Math.cos(angle) * radius;
        const dy = Math.sin(angle) * radius;
        const grad = ctx.createLinearGradient(cx - dx, cy - dy, cx + dx, cy + dy);
        grad.addColorStop(0, color);
        grad.addColorStop(1, gradientMap[color.toUpperCase()] || color);
        fillStyle = grad;
      } else {
        const grad = ctx.createRadialGradient(cx, cy, radius * 0.3, cx, cy, radius);
        grad.addColorStop(0, color);
        grad.addColorStop(1, gradientMap[color.toUpperCase()] || color);
        fillStyle = grad;
      }
      ctx.fillStyle = fillStyle;
      ctx.beginPath();
      ctx.arc(cx, cy, radius, 0, Math.PI * 2);
      ctx.fill();
    }
  }

  if (currentZoneIndexTop + currentZoneIndexBottom < appearingZones.length) {
    if (currentZoneIndexTop + currentZoneIndexBottom < appearingZones.length) {
      // Zone du haut
      if (currentZoneIndexTop + currentZoneIndexBottom < appearingZones.length) {
        const zoneTop = appearingZones[currentZoneIndexTop];
        for (let j = 0; j <= currentCircleIndexTop; j++) {
          if (j >= zoneTop.length) break;
          const { x, y, color } = zoneTop[j];
          const cx = x * radius;
          const cy = y * radius;
          if (isInCenterRect(cx, cy)) continue;
          const gradient = ctx.createRadialGradient(cx, cy, radius * 0.3, cx, cy, radius);
          gradient.addColorStop(0, color);
          gradient.addColorStop(1, gradientMap[color.toUpperCase()] || color);
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(cx, cy, radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      // Zone du bas
      if (currentZoneIndexTop + currentZoneIndexBottom < appearingZones.length &&
          appearingZones.length - 1 - currentZoneIndexBottom !== currentZoneIndexTop) {
        const zoneBottom = appearingZones[appearingZones.length - 1 - currentZoneIndexBottom];
        for (let j = 0; j <= currentCircleIndexBottom; j++) {
          if (j >= zoneBottom.length) break;
          const { x, y, color } = zoneBottom[j];
          const cx = x * radius;
          const cy = y * radius;
          if (isInCenterRect(cx, cy)) continue;
          const gradient = ctx.createRadialGradient(cx, cy, radius * 0.3, cx, cy, radius);
          gradient.addColorStop(0, color);
          gradient.addColorStop(1, gradientMap[color.toUpperCase()] || color);
          ctx.fillStyle = gradient;
          ctx.beginPath();
          ctx.arc(cx, cy, radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
    }

    // Animation des cercles pour chaque zone (plus rapide : +5 à chaque frame)
    let needNextFrame = false;
    const step = 5; // accélération ici
    if (currentZoneIndexTop + currentZoneIndexBottom < appearingZones.length) {
      const zoneTop = appearingZones[currentZoneIndexTop];
      if (currentCircleIndexTop < zoneTop.length - 1) {
        currentCircleIndexTop += step;
        if (currentCircleIndexTop > zoneTop.length - 1) currentCircleIndexTop = zoneTop.length - 1;
        needNextFrame = true;
      } else if (currentZoneIndexTop + currentZoneIndexBottom < appearingZones.length) {
        currentZoneIndexTop++;
        currentCircleIndexTop = 0;
        needNextFrame = true;
      }
      // Zone du bas
      if (appearingZones.length - 1 - currentZoneIndexBottom !== currentZoneIndexTop) {
        const zoneBottom = appearingZones[appearingZones.length - 1 - currentZoneIndexBottom];
        if (currentCircleIndexBottom < zoneBottom.length - 1) {
          currentCircleIndexBottom += step;
          if (currentCircleIndexBottom > zoneBottom.length - 1) currentCircleIndexBottom = zoneBottom.length - 1;
          needNextFrame = true;
        } else if (currentZoneIndexTop + currentZoneIndexBottom < appearingZones.length) {
          currentZoneIndexBottom++;
          currentCircleIndexBottom = 0;
          needNextFrame = true;
        }
      }
    }
    if (needNextFrame) {
      requestAnimationFrame(animate);
    }
  }
}

// Fonction utilitaire pour limiter les appels de redimensionnement
function debounce(func, wait) {
  let timeout;
  return function() {
    const context = this;
    const args = arguments;
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      func.apply(context, args);
    }, wait);
  };
}

// Essaye de jouer la musique dès que possible
document.getElementById('backgroundMusic').play().catch(() => {});

// Initialisation
window.addEventListener("load", () => {
  window.addEventListener("resize", debounce(resizeCanvas, 250));
  resizeCanvas();
  requestAnimationFrame(animate);
});
</script>
</body>
</html>