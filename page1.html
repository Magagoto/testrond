<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8">
  <title>Balle Gyroscope D√©grad√©e</title>
  <style>
    html, body {
      margin: 0;
      height: 100%;
      overflow: hidden;
      /* Fond sombre mat avec motif SVG grille de ronds align√©s */
      background: #111;
      /* SVG de fond : grille de ronds align√©s + UNE SEULE ligne continue qui traverse la page de fa√ßon "al√©atoire" */
      background-image: url('data:image/svg+xml;utf8,<svg width="120" height="120" xmlns="http://www.w3.org/2000/svg"><circle cx="30" cy="30" r="16" fill="none" stroke="%23222" stroke-width="1.2"/><circle cx="90" cy="30" r="16" fill="none" stroke="%23222" stroke-width="1.2"/><circle cx="30" cy="90" r="16" fill="none" stroke="%23222" stroke-width="1.2"/><circle cx="90" cy="90" r="16" fill="none" stroke="%23222" stroke-width="1.2"/><polyline points="90,0 90,30 30,30 30,90 90,90 90,120" fill="none" stroke="%23222" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" opacity="0.7"/></svg>');
      font-family: sans-serif;
      display: flex;
      justify-content: center;
      align-items: center;
    }

    #ball {
      position: absolute;
      width: 80px;
      height: 80px;
      border-radius: 50%;
      background: #0b03fc6e;
      background-size: 150% 150%;
      background-position: center;
      transition: background 0.3s, box-shadow 0.3s;
      /* Effet n√©on autour de la balle */
      box-shadow:
        0 0 24px 8px #00ffcc,
        0 0 48px 16px #2a489988,
        0 2px 16px #00ffcc44;
      z-index: 10;
      isolation: isolate;
    }
    #ball:hover {
      box-shadow:
        0 0 48px 16px #00ffcc,
        0 0 64px 24px #2a4899cc,
        0 2px 24px #00ffcc88;
    }
    #ball::after {
      content: "";
      position: absolute;
      left: 50%; top: 50%;
      width: 220px;
      height: 80px;
      pointer-events: none;
      border-radius: 50%;
      /* Effet de halo/fum√©e dynamique */
      transform: translate(-50%, -50%) scaleX(var(--ball-blur, 0.1));
      opacity: var(--ball-blur-opacity, 0);
      background: radial-gradient(ellipse at 60% 50%, #00ffcc55 0%, #2a4899cc 60%, #1110 100%);
      filter: blur(18px);
      transition: opacity 0.18s, transform 0.09s;
      z-index: -1;
      mix-blend-mode: lighten;
    }

    #start-btn {
      padding: 1em 2.5em;
      font-size: 1.1em;
      background: rgba(0,255,204,0.13);
      color: #00ffcc;
      border: 2px solid #00ffcc;
      border-radius: 12px;
      cursor: pointer;
      z-index: 2;
      position: absolute;
      left: 50%;
      top: 38%; /* au-dessus de la balle */
      transform: translate(-50%, -100%);
      margin-top: 0;
      font-family: 'Fira Mono', 'Consolas', monospace;
      font-weight: 600;
      box-shadow: 0 2px 16px #00ffcc22, 0 1px 8px #0004;
      backdrop-filter: blur(2px);
      letter-spacing: 1px;
      transition: background 0.3s, color 0.3s, border 0.3s, box-shadow 0.3s;
    }
    #start-btn:hover {
      background: #00ffcc;
      color: #111;
      border: 2px solid #00ffcc;
      box-shadow: 0 0 24px #00ffcc88;
    }

    #info {
      position: absolute;
      bottom: 20px;
      color: white;
      font-family: sans-serif;
      font-size: 0.9em;
      display: none; /* cach√©, le texte va dans la banni√®re */
    }
    
    /* Style pour les cages rectangulaires */
    .cage {
      position: absolute;
      /* Suppression des bordures */
      box-sizing: border-box;
    }
    
    /* Cages du haut */
    .cage-top {
      top: 70px;
      height: 44px;    /* encore augment√© */
      width: 37%;      /* encore augment√© */
    }
    
    #cage-top-1 {
      left: 12%;
    }
    
    #cage-top-2 {
      right: 12%;
    }
    
    /* Cages du bas */
    .cage-bottom {
      bottom: 10px;
      height: 44px;    /* encore augment√© */
      width: 37%;      /* encore augment√© */
    }
    
    #cage-bottom-1 {
      left: 12%;
    }
    
    #cage-bottom-2 {
      right: 12%;
    }
    
    /* Cages lat√©rales (3 de chaque c√¥t√©) */
    .cage-left, .cage-right {
      width: 44px;     /* encore augment√© */
      height: 20%;     /* encore augment√© */
    }
    
    #cage-left-1 {
      left: 10px;
      top: 20%;
    }
    
    #cage-left-2 {
      left: 10px;
      top: 42.5%;
    }
    
    #cage-left-3 {
      left: 10px;
      top: 65%;
    }
    
    #cage-right-1 {
      right: 10px;
      top: 20%;
    }
    
    #cage-right-2 {
      right: 10px;
      top: 42.5%;
    }
    
    #cage-right-3 {
      right: 10px;
      top: 65%;
    }

    /* Styles pour les coins des cages */
    .cage-corner {
      position: absolute;
      background: white;
    }

    /* Coins pour les cages du haut */
    .cage-top .corner-left {
      top: 0;
      left: -10px; /* Positionner √† gauche */
      width: 10px; /* Rectangle vertical */
      height: 180%; /* Allonger la hauteur */
    }
    .cage-top .corner-right {
      top: 0;
      right: -10px; /* Positionner √† droite */
      width: 10px; /* Rectangle vertical */
      height: 180%; /* Allonger la hauteur */
    }

    /* Coins pour les cages du bas */
    .cage-bottom .corner-left {
      bottom: 0;
      left: -10px; /* Positionner √† gauche */
      width: 10px; /* Rectangle vertical */
      height: 180%; /* Allonger la hauteur */
    }
    .cage-bottom .corner-right {
      bottom: 0;
      right: -10px; /* Positionner √† droite */
      width: 10px; /* Rectangle vertical */
      height: 180%; /* Allonger la hauteur */
    }

    /* Coins pour les cages lat√©rales gauche */
    .cage-left .corner-top {
      top: -10px; /* Positionner en haut */
      left: 0;
      width: 180%; /* Allonger la largeur */
      height: 10px; /* Rectangle horizontal */
    }
    .cage-left .corner-bottom {
      bottom: -10px; /* Positionner en bas */
      left: 0;
      width: 180%; /* Allonger la largeur */
      height: 10px; /* Rectangle horizontal */
    }

    /* Coins pour les cages lat√©rales droite */
    .cage-right .corner-top {
      top: -10px; /* Positionner en haut */
      right: 0;
      width: 180%; /* Allonger la largeur */
      height: 10px; /* Rectangle horizontal */
    }
    .cage-right .corner-bottom {
      bottom: -10px; /* Positionner en bas */
      right: 0;
      width: 180%; /* Allonger la largeur */
      height: 10px; /* Rectangle horizontal */
    }

    @keyframes blink {
        from { opacity: 1; }
        to { opacity: 0.3; }
    }

    /* Banni√®re en haut */
    #game-banner {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      min-width: 340px;
      max-width: 100vw;
      height: 68px; /* plus large */
      background: linear-gradient(180deg, #182c4c 0%, #111 100%) !important; /* bleu plus fonc√© */
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
      box-shadow: 0 2px 8px #0008;
      gap: 32px; /* espace entre les √©l√©ments */
    }
    #banner-content {
      width: 100%;
      max-width: 900px;
      display: flex;
      justify-content: flex-start; /* aligner √† gauche */
      align-items: center;
      padding: 0 30px;
      gap: 32px; /* espace entre les √©l√©ments */
    }
    #timer-display {
      position: static;
      color: white;
      font-size: 24px;
      font-weight: bold;
      font-family: sans-serif;
      z-index: 10;
      margin: 0 10px;
      margin-right: 12px; /* espace √† droite du chrono */
    }
    #score-display {
      position: static;
      color: white;
      font-size: 24px;
      font-weight: bold;
      margin: 0 10px;
    }
    #gyro-status {
      color: #00ffcc;
      font-family: 'Fira Mono', 'Consolas', monospace;
      font-size: 1.1em;
      font-weight: 600;
      letter-spacing: 1px;
      text-shadow: 0 0 8px #00ffcc, 0 0 2px #fff;
      margin-left: 24px;
      transition: opacity 0.3s;
      opacity: 0;
      animation: none;
    }
    #gyro-status.active {
      opacity: 1;
      animation: blink 1.2s infinite alternate;
    }

    /* Style pour le pop-up du tutoriel */
    .tutorial-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.85);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }

    .tutorial-overlay.active {
      opacity: 1;
      pointer-events: all;
    }

    .tutorial-container {
      position: relative;
      width: 95%;
      max-width: 800px; /* augment√© de 500px √† 800px */
      max-height: 88vh;
      overflow-y: auto;
      background: linear-gradient(145deg, #182c4c 0%, #111 100%);
      border: 2px solid #00ffcc;
      border-radius: 16px;
      padding: 24px;
      color: white;
      box-shadow: 0 0 30px #00ffcc44, 0 0 15px #2a489966;
      margin: 0 10px;
    }

    .tutorial-header {
      text-align: center;
      margin-bottom: 20px;
      color: #00ffcc;
      text-shadow: 0 0 10px #00ffcc66;
      font-family: 'Fira Mono', 'Consolas', monospace;
      letter-spacing: 1px;
    }

    .tutorial-header h2 {
      font-size: 2em;
      font-weight: 600;
      margin: 0.5em 0;
    }

    .tutorial-content {
      margin-bottom: 24px;
      line-height: 1.6;
      font-family: sans-serif;
      font-size: 18px; /* augment√© de 16px */
    }

    .tutorial-step {
      display: flex;
      margin-bottom: 24px;
      padding-bottom: 8px;
      align-items: flex-start;
    }

    .step-number {
      background: #00ffcc;
      color: #111;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      display: flex;
      justify-content: center;
      align-items: center;
      font-weight: bold;
      margin-right: 18px;
      flex-shrink: 0;
      font-family: 'Fira Mono', 'Consolas', monospace;
      font-size: 20px;
    }

    .tutorial-btn {
      padding: 1em 2em;
      font-size: 1.2em;
      background: rgba(0,255,204,0.13);
      color: #00ffcc;
      border: 2px solid #00ffcc;
      border-radius: 12px;
      cursor: pointer;
      font-family: 'Fira Mono', 'Consolas', monospace;
      font-weight: 600;
      box-shadow: 0 2px 16px #00ffcc22, 0 1px 8px #0004;
      backdrop-filter: blur(2px);
      letter-spacing: 1px;
      transition: background 0.3s, color 0.3s, border 0.3s, box-shadow 0.3s;
      display: block;
      margin: 0 auto;
      text-align: center;
      width: 100%;
      max-width: 320px; /* augment√© de 280px */
    }

    .highlight {
      color: #00ffcc;
      font-weight: bold;
      text-shadow: 0 0 6px #00ffcc33;
    }

    /* Ajustements sp√©cifiques pour mobile et tablette */
    @media (max-width: 800px) {
      .tutorial-container {
        padding: 24px;
        width: 98%;
        max-width: none; /* prend toute la largeur disponible */
        max-height: 94vh;
        border-radius: 12px;
        margin: 10px auto;
      }
      
      .tutorial-header h2 {
        font-size: 2.4em;
        margin-bottom: 0.6em;
      }
      
      .tutorial-content {
        font-size: 1.5em;
        line-height: 1.5;
      }
      
      .step-number {
        width: 50px;
        height: 50px;
        font-size: 24px;
        margin-right: 20px;
      }
      
      .tutorial-btn {
        margin-top: 20px;
        padding: 1.2em 1em;
        font-size: 1.6em;
        max-width: 90%; /* prend 90% de la largeur du conteneur */
        border-radius: 14px;
      }
      
      /* Ajuster l'espacement des paragraphes pour une meilleure lisibilit√© */
      .tutorial-step p {
        margin: 1em 0;
      }
      
      /* Augmenter l'espace entre les √©tapes */
      .tutorial-step {
        margin-bottom: 36px;
        padding-bottom: 14px;
      }
    }

    /* Ajustements pour les t√©l√©phones */
    @media (max-width: 480px) {
      .tutorial-container {
        padding: 20px;
        width: 100%;
        max-height: 96vh;
        border-radius: 10px;
        margin: 5px 0;
        border-width: 1px;
      }
      
      .tutorial-content {
        font-size: 1.3em;
      }
      
      .step-number {
        width: 46px;
        height: 46px;
        margin-right: 16px;
      }
      
      .tutorial-btn {
        max-width: 100%;
        margin-top: 10px;
      }
    }

    /* Ajustements pour les tr√®s petits √©crans */
    @media (max-width: 320px) {
      .tutorial-container {
        padding: 15px;
      }
      
      .tutorial-header h2 {
        font-size: 2em;
      }
      
      .tutorial-content {
        font-size: 1.2em;
      }
      
      .step-number {
        width: 40px;
        height: 40px;
        font-size: 20px;
        margin-right: 12px;
      }
    }

    /* Responsive : banni√®re plus large sur mobile */
    @media (max-width: 600px) {
      #game-banner {
        height: 80px;
        min-width: 100vw;
        padding-left: 0;
        padding-right: 0;
        background: linear-gradient(180deg, #182c4c 0%, #111 100%) !important;
      }
      #banner-content {
        max-width: 100vw;
        padding: 0 8px;
      }
    }

    /* Style pour l'affichage du score final */
    .score-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0);
      display: flex;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      transition: opacity 1s, background-color 1s;
      pointer-events: none;
    }

    .score-overlay.active {
      opacity: 1;
      background-color: rgba(0, 0, 0, 0.85);
      pointer-events: all;
    }

    .score-container {
      position: relative;
      width: 95%;
      max-width: 500px;
      background: linear-gradient(145deg, #182c4c 0%, #111 100%);
      border: 2px solid #00ffcc;
      border-radius: 16px;
      padding: 30px;
      color: white;
      box-shadow: 0 0 30px #00ffcc44, 0 0 15px #2a489966;
      text-align: center;
      transform: translateY(30px);
      opacity: 0;
      transition: transform 0.8s ease-out, opacity 0.8s ease-out;
    }

    .score-overlay.active .score-container {
      transform: translateY(0);
      opacity: 1;
    }

    .score-header {
      margin-bottom: 30px;
      color: #00ffcc;
      text-shadow: 0 0 10px #00ffcc66;
      font-family: 'Fira Mono', 'Consolas', monospace;
      letter-spacing: 1px;
    }

    .score-header h2 {
      font-size: 2.2em;
      font-weight: 600;
      margin: 0;
    }

    .score-content {
      margin-bottom: 30px;
    }

    .final-score {
      font-size: 3.5em;
      font-weight: bold;
      margin: 20px 0;
      color: #00ffcc;
      text-shadow: 0 0 15px #00ffcc88;
      font-family: 'Fira Mono', 'Consolas', monospace;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 10px;
    }

    .score-label {
      font-size: 0.4em;
      opacity: 0.8;
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .score-message {
      font-size: 1.3em;
      opacity: 0.9;
      margin-top: 20px;
    }

    .score-btn {
      padding: 1em 2em;
      font-size: 1.2em;
      background: rgba(0,255,204,0.13);
      color: #00ffcc;
      border: 2px solid #00ffcc;
      border-radius: 12px;
      cursor: pointer;
      font-family: 'Fira Mono', 'Consolas', monospace;
      font-weight: 600;
      box-shadow: 0 2px 16px #00ffcc22, 0 1px 8px #0004;
      backdrop-filter: blur(2px);
      letter-spacing: 1px;
      transition: background 0.3s, color 0.3s, border 0.3s, box-shadow 0.3s;
      display: block;
      margin: 0 auto;
      width: 100%;
      max-width: 300px;
    }

    .score-btn:hover {
      background: #00ffcc;
      color: #111;
      border: 2px solid #00ffcc;
      box-shadow: 0 0 24px #00ffcc88;
    }

    @media (max-width: 600px) {
      .score-container {
        width: 90%;
        padding: 25px;
      }
      
      .score-header h2 {
        font-size: 2em;
      }
      
      .final-score {
        font-size: 3em;
      }
      
      .score-message {
        font-size: 1.1em;
      }
      
      .score-btn {
        font-size: 1.1em;
        padding: 0.9em 1.5em;
      }
    }
  </style>
</head>
<body>
  <!-- Banni√®re du jeu -->
  <div id="game-banner">
    <div id="banner-content">
      <span id="timer-display">00:05</span>
      <span id="score-display">Score: 0</span>
      <span id="gyro-status"></span>
    </div>
  </div>

  <!-- Pop-up du tutoriel -->
  <div class="tutorial-overlay" id="tutorial-overlay">
    <div class="tutorial-container">
      <div class="tutorial-header">
        <h2>Rite d'Alignement √ânerg√©tique</h2>
      </div>
      <div class="tutorial-content">
        <div class="tutorial-step">
          <div class="step-number">1</div>
          <div>
            <p>Bienvenue, Raffineur.</p>
            <p>Tu t'appr√™tes √† entamer un <span class="highlight">rite d'alignement √©nerg√©tique</span>.</p>
            <p>Pour ce faire, saisis ton artefact ‚Äî ton t√©l√©phone ‚Äî et incline-le pour guider l'√©nergie jusqu'√† son r√©ceptacle.</p>
          </div>
        </div>
        
        <div class="tutorial-step">
          <div class="step-number">2</div>
          <div>
            <p>Observe sa teinte : elle t'indique la cage qui lui correspond. Il te suffit d'amener l'√©nergie dans un r√©ceptacle de m√™me couleur.</p>
            <p>Ton objectif est simple : faire correspondre la couleur de l'√©nergie avec celle des cages.</p>
            <p>Si les √©nergies s'accordent, tu gagnes <span class="highlight">+2 points</span>. En cas de dissonance, tu perds <span class="highlight">-1 point</span>.</p>
          </div>
        </div>
        
        <div class="tutorial-step">
          <div class="step-number">3</div>
          <div>
            <p>√Ä chaque contact, l'√©nergie change de forme ‚Äî une <span class="highlight">transmutation al√©atoire</span>.</p>
            <p>Les r√©ceptacles eux aussi sont instables : leurs dimensions fluctuent au fil du temps.</p>
          </div>
        </div>
        
        <div class="tutorial-step">
          <div class="step-number">4</div>
          <div>
            <p><span class="highlight">‚è± Tu as 1 minute et 10 secondes</span> pour affiner ta trajectoire et r√©colter un maximum de points.</p>
            <p>Respire. Ressens. Laisse-toi guider par l'√©quilibre.</p>
            <p>Bonne chance, Raffineur.</p>
          </div>
        </div>
      </div>
      <button class="tutorial-btn" id="tutorial-close-btn">J'ai compris, commencer le rite</button>
    </div>
  </div>

  <!-- Ajout de la superposition pour l'affichage du score final -->
  <div class="score-overlay" id="score-overlay">
    <div class="score-container">
      <div class="score-header">
        <h2>Raffinage Termin√©</h2>
      </div>
      <div class="score-content">
        <div class="final-score">
          <span id="final-score-value">0</span>
          <span class="score-label">points</span>
        </div>
        <p class="score-message">Ton alignement √©nerg√©tique est achev√©.</p>
      </div>
      <button class="score-btn" id="restart-btn">Retourner √† la page principale</button>
    </div>
  </div>

  <button id="start-btn">Activer le gyroscope</button>
  <div id="ball"></div>
  <div id="info"></div>
  
  <!-- Ajout des √©l√©ments audio -->
  <audio id="pointSound" src="SONORE/1point+.mp3" preload="auto"></audio>
  <audio id="backgroundMusic" src="SONORE/ambiancegyro.mp3" loop preload="auto"></audio>
  <audio id="endGameSound" src="SONORE/Fin de raffinage.mp3" preload="auto"></audio>
  
  <!-- Cages rectangulaires -->
  <div id="cage-top-1" class="cage cage-top">
    <div class="cage-corner corner-left"></div>
    <div class="cage-corner corner-right"></div>
  </div>
  <div id="cage-top-2" class="cage cage-top">
    <div class="cage-corner corner-left"></div>
    <div class="cage-corner corner-right"></div>
  </div>
  
  <div id="cage-bottom-1" class="cage cage-bottom">
    <div class="cage-corner corner-left"></div>
    <div class="cage-corner corner-right"></div>
  </div>
  <div id="cage-bottom-2" class="cage cage-bottom">
    <div class="cage-corner corner-left"></div>
    <div class="cage-corner corner-right"></div>
  </div>
  
  <div id="cage-left-1" class="cage cage-left">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>
  <div id="cage-left-2" class="cage cage-left">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>
  <div id="cage-left-3" class="cage cage-left">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>
  
  <div id="cage-right-1" class="cage cage-right">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>
  <div id="cage-right-2" class="cage cage-right">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>
  <div id="cage-right-3" class="cage cage-right">
    <div class="cage-corner corner-top"></div>
    <div class="cage-corner corner-bottom"></div>
  </div>

  <script>
    const ball = document.getElementById("ball");
    const startBtn = document.getElementById("start-btn");
    const info = document.getElementById("info");
    const pointSound = document.getElementById("pointSound");
    const backgroundMusic = document.getElementById("backgroundMusic"); // Ajout de la r√©f√©rence √† la musique
    const endGameSound = document.getElementById("endGameSound"); // Ajout de la r√©f√©rence au son de fin
    const gyroStatus = document.getElementById("gyro-status");
    
    // √âl√©ments du tutoriel
    const tutorialOverlay = document.getElementById("tutorial-overlay");
    const tutorialCloseBtn = document.getElementById("tutorial-close-btn");

    // √âl√©ments pour l'affichage du score final
    const scoreOverlay = document.getElementById("score-overlay");
    const finalScoreValue = document.getElementById("final-score-value");
    const restartBtn = document.getElementById("restart-btn");

    // Afficher le tutoriel au chargement de la page
    window.addEventListener("DOMContentLoaded", () => {
      // Attendre un peu avant d'afficher pour permettre le chargement complet
      setTimeout(() => {
        tutorialOverlay.classList.add("active");
      }, 500);
    });

    // Fermer le tutoriel quand le bouton est cliqu√©
    tutorialCloseBtn.addEventListener("click", () => {
      tutorialOverlay.classList.remove("active");
      preloadSounds();
    });

    // √âcouteur d'√©v√©nement pour le bouton de red√©marrage
    restartBtn.addEventListener("click", () => {
      scoreOverlay.classList.remove("active");
      startBtn.style.display = "block";
      // R√©initialiser la position de la balle
      posX = window.innerWidth / 2;
      posY = window.innerHeight / 2;
      velX = 0;
      velY = 0;
      ball.style.left = posX + "px";
      ball.style.top = posY + "px";
    });

    // D√©grad√©s cycliques pr√©d√©finis
    const gradients = [
      ["#00A993", "#E68B4A"],
      ["#E68B4A", "#7A1619"],
      ["#7A1619", "#362777"],
      ["#362777", "#EB7AAE"],
      ["#EB7AAE", "#0069AA"],
      ["#0069AA", "#DC0C15"],
      ["#DC0C15", "#E03A8D"],
      ["#E03A8D", "#FFFFFF"],
      ["#FFFFFF", "#2A4899"],
      ["#2A4899", "#00A993"]
    ];

    const scoreDisplay = document.getElementById("score-display");
    const timerDisplay = document.getElementById("timer-display");

    let score = 0;
    let gameActive = false;
    let timerSeconds = 5; // Dur√©e de la partie en secondes (r√©duite √† 5 secondes)
    let timerInterval;
    updateScoreDisplay();

    // Fonction pour mettre √† jour l'affichage du score
    function updateScoreDisplay() {
      scoreDisplay.textContent = `Score: ${score}`;
    }

    // Assigner des identifiants uniques √† chaque gradient pour pouvoir les comparer
    const gradientIds = {};
    gradients.forEach((gradient, index) => {
      gradientIds[`${gradient[0]}_${gradient[1]}`] = index;
    });

    // Fonction pour d√©terminer si deux couleurs sont similaires
    function areSimilarColors(color1, color2) {
      const rgb1 = colorToRgb(color1);
      const rgb2 = colorToRgb(color2);
      if (!rgb1 || !rgb2) return false;
      const distance = Math.sqrt(
        Math.pow(rgb1.r - rgb2.r, 2) +
        Math.pow(rgb1.g - rgb2.g, 2) +
        Math.pow(rgb1.b - rgb2.b, 2)
      );
      const tolerance = 30;
      return distance < tolerance;
    }

    // Fonction pour convertir une couleur (hex ou rgb) en valeurs RGB
    function colorToRgb(color) {
      const rgbMatch = color.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
      if (rgbMatch) {
        return {
          r: parseInt(rgbMatch[1]),
          g: parseInt(rgbMatch[2]),
          b: parseInt(rgbMatch[3])
        };
      }
      const hexMatch = color.match(/#([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})([0-9A-Fa-f]{2})/);
      if (hexMatch) {
        return {
          r: parseInt(hexMatch[1], 16),
          g: parseInt(hexMatch[2], 16),
          b: parseInt(hexMatch[3], 16)
        };
      }
      return null;
    }

    // Appliquer un d√©grad√© diff√©rent √† chaque cage
    function assignUniqueGradients() {
      const cages = document.querySelectorAll('.cage');
      
      // Cr√©er une copie du tableau de gradients pour pouvoir en retirer au fur et √† mesure
      let availableGradients = [...gradients];
      
      // M√©langer le tableau pour une attribution al√©atoire
      availableGradients = shuffleArray(availableGradients);
      
      // Assigner un d√©grad√© unique √† chaque cage
      cages.forEach((cage, index) => {
        if (index < availableGradients.length) {
          const gradient = availableGradients[index];
          cage.style.background = `linear-gradient(135deg, ${gradient[0]}, ${gradient[1]})`;
        }
      });
    }
    
    // Fonction pour m√©langer un tableau (algorithme de Fisher-Yates)
    function shuffleArray(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // Appliquer un d√©grad√© al√©atoire √† la balle
    let currentBallGradientIndex = Math.floor(Math.random() * gradients.length);
    ball.style.background = `linear-gradient(135deg, ${gradients[currentBallGradientIndex][0]}, ${gradients[currentBallGradientIndex][1]})`;

    // Assigner des d√©grad√©s uniques aux cages
    assignUniqueGradients();

    // Met √† jour la couleur des coins selon le d√©grad√© r√©el appliqu√© en CSS
    function updateCornerColors() {
      const cages = document.querySelectorAll('.cage');
      cages.forEach(cage => {
        // R√©cup√©rer le style de fond actuel de la cage
        const computedStyle = window.getComputedStyle(cage);
        const backgroundImage = computedStyle.backgroundImage;
        
        // Extraire les couleurs du gradient
        let colorStart, colorEnd;
        
        // Extraire les couleurs depuis la propri√©t√© backgroundImage
        const colors = backgroundImage.match(/(#[0-9A-Fa-f]{6}|rgb\([^)]+\))/gi);
        if (colors && colors.length >= 2) {
          colorStart = colors[0];
          colorEnd = colors[1];
        } else {
          // Valeurs par d√©faut si on ne peut pas extraire les couleurs
          colorStart = "#FFFFFF";
          colorEnd = "#CCCCCC";
        }

        const corners = cage.querySelectorAll('.cage-corner');
        corners.forEach(corner => {
          // Cages du haut et du bas
          if (cage.classList.contains('cage-top') || cage.classList.contains('cage-bottom')) {
            if (corner.classList.contains('corner-left')) {
              corner.style.background = colorStart;
            }
            if (corner.classList.contains('corner-right')) {
              corner.style.background = colorEnd;
            }
          }
          // Cages de gauche
          else if (cage.classList.contains('cage-left')) {
            if (corner.classList.contains('corner-top')) {
              corner.style.background = colorStart;
            }
            if (corner.classList.contains('corner-bottom')) {
              corner.style.background = colorEnd;
            }
          }
          // Cages de droite
          else if (cage.classList.contains('cage-right')) {
            if (corner.classList.contains('corner-top')) {
              corner.style.background = colorStart;
            }
            if (corner.classList.contains('corner-bottom')) {
              corner.style.background = colorEnd;
            }
          }
        });
      });
    }

    // On doit appeler updateCornerColors APR√àS assignUniqueGradients
    updateCornerColors();

    let posX = window.innerWidth / 2;
    let posY = window.innerHeight / 2;
    let velX = 0;
    let velY = 0;

    const ballSize = 80;
    const friction = 0.98;
    
    // R√©duction IMPORTANTE de la sensibilit√© (avant: 0.15)
    const accelerationFactor = 0.01;
    
    // Variable pour suivre le dernier changement de couleur
    let lastColorChange = 0;
    const colorChangeDelay = 300; // D√©lai minimum entre les changements de couleur (ms)

    function updateBallPosition() {
      posX += velX;
      posY += velY;

      // V√©rifier les collisions avec les bords de l'√©cran
      if (posX <= 0) {
        posX = 0;
        velX *= -0.7;
      } else if (posX >= window.innerWidth - ballSize) {
        posX = window.innerWidth - ballSize;
        velX *= -0.7;
      }

      if (posY <= 0) {
        posY = 0;
        velY *= -0.7;
      } else if (posY >= window.innerHeight - ballSize) {
        posY = window.innerHeight - ballSize;
        velY *= -0.7;
      }

      // Collision avec les cages rectangulaires
      checkCageCollisions();

      velX *= friction;
      velY *= friction; (1.2);

      // Effet de vitesse (motion blur) selon la vitesse de la balle
      const speed = Math.sqrt(velX * velX + velY * velY);
      const blurScale = Math.min(1.5, speed * 0.7);
      const blurOpacity = Math.min(0.55, speed * 0.18);
      ball.style.setProperty('--ball-blur', blurScale.toFixed(2));
      ball.style.setProperty('--ball-blur-opacity', blurOpacity.toFixed(2));

      ball.style.left = posX + "px";
      ball.style.top = posY + "px";

      requestAnimationFrame(updateBallPosition);
    }

    function changeBallColor() {
      const now = Date.now();
      // V√©rifier si on peut changer la couleur (pour √©viter les changements trop rapides)
      if (now - lastColorChange >= colorChangeDelay) {
        // Choisir un nouvel index diff√©rent de l'actuel
        let newIndex;
        do {
          newIndex = Math.floor(Math.random() * gradients.length);    
        } while (newIndex === currentBallGradientIndex);
        
        currentBallGradientIndex = newIndex;
        ball.style.background = `linear-gradient(135deg, ${gradients[currentBallGradientIndex][0]}, ${gradients[currentBallGradientIndex][1]})`;
        lastColorChange = now;
      }
    }
    
    // Configuration des animations am√©lior√©es - Modifications pour des animations plus dynamiques
    const cageAnimationConfig = {
      minDuration: 2000,  // Dur√©e minimum d'un cycle d'animation r√©duite (avant: 5000)
      maxDuration: 4000,  // Dur√©e maximum d'un cycle d'animation r√©duite (avant: 9000)
      minSize: 0.6,       // Taille minimum plus petite (avant: 0.8)
      maxSize: 1.4,       // Taille maximum plus grande (avant: 1.2)
    };

    // Stocker les dimensions originales des cages
    const cageOriginalDimensions = {};

    // Variable pour suivre l'√©tat des collisions
    const collisionCooldowns = {};

    // Ajouter une transition sur les coins pour l'animation fluide (√† faire une seule fois)
    function addCornerTransitions() {
      document.querySelectorAll('.cage-corner').forEach(corner => {
        corner.style.transition = "width 0.7s, height 0.7s";
      });
    }
    addCornerTransitions();

    // Initialiser les animations des cages avec des transitions CSS plus rapides
    function initCageAnimations() {
      const cages = document.querySelectorAll('.cage');
      
      cages.forEach((cage, index) => {
        // Transition plus rapide pour des animations plus dynamiques
        cage.style.transition = "width 0.8s ease-in-out, height 0.8s ease-in-out, top 0.8s ease-in-out";

        // Stocker les dimensions originales
        const rect = cage.getBoundingClientRect();
        const style = window.getComputedStyle(cage);
        
        cageOriginalDimensions[cage.id] = {
          width: rect.width,
          height: rect.height,
          left: parseFloat(style.left || "0"),
          top: parseFloat(style.top || "0"),
          right: parseFloat(style.right || "0"),
          bottom: parseFloat(style.bottom || "0")
        };

        // Initialiser le cooldown de collision
        collisionCooldowns[cage.id] = 0;

        // D√©marrer l'animation avec un d√©lai al√©atoire pour d√©synchroniser
        setTimeout(() => {
          animateCage(cage);
        }, Math.random() * 1000); // D√©lai plus court pour commencer les animations plus rapidement
      });
    }

    // Animation d'une cage individuelle avec possibilit√© d'animer uniquement les coins
    function animateCage(cage) {
      const original = cageOriginalDimensions[cage.id];
      const isHorizontal = cage.classList.contains('cage-top') || cage.classList.contains('cage-bottom');
      const isSideLeft = cage.classList.contains('cage-left');
      const isSideRight = cage.classList.contains('cage-right');
      const corners = cage.querySelectorAll('.cage-corner');

      // G√©n√©rer des valeurs al√©atoires pour cette animation
      const duration = Math.random() * 
        (cageAnimationConfig.maxDuration - cageAnimationConfig.minDuration) + 
        cageAnimationConfig.minDuration;
      const sizeFactor1 = Math.random() * 
        (cageAnimationConfig.maxSize - cageAnimationConfig.minSize) + 
        cageAnimationConfig.minSize;
      const sizeFactor2 = Math.random() * 
        (cageAnimationConfig.maxSize - cageAnimationConfig.minSize) + 
        cageAnimationConfig.minSize;

      // 30% de chance d'animer uniquement les coins
      const onlyCorners = Math.random() < 0.3;

      // 20% de chance d'allonger ENCORE PLUS les coins (super allongement)
      const superLongCorners = onlyCorners && Math.random() < 0.2;

      if (onlyCorners) {
        // Remettre la cage principale √† sa taille d'origine
        if (isHorizontal) {
          cage.style.width = `${original.width}px`;
          cage.style.height = `${original.height}px`;
        } else if (isSideLeft || isSideRight) {
          cage.style.width = `${original.width}px`;
          cage.style.height = `${original.height}px`;
        }

        // Allonger fortement les coins, ou ENCORE PLUS si superLongCorners
        corners.forEach(corner => {
          if (isHorizontal) {
            // Coins verticaux‚ÄØ: on allonge la hauteur
            if (superLongCorners) {
              corner.style.height = `${original.height * 7}px`; // super allong√©
            } else {
              corner.style.height = `${original.height * 3.5}px`; // tr√®s allong√©
            }
            corner.style.width = `10px`;
          } else if (isSideLeft || isSideRight) {
            // Coins horizontaux‚ÄØ: on allonge la largeur
            if (superLongCorners) {
              corner.style.width = `${original.width * 7}px`; // super allong√©
            } else {
              corner.style.width = `${original.width * 3.5}px`; // tr√®s allong√©
            }
            corner.style.height = `10px`;
          }
        });
      } else {
        // Animation normale de la cage principale
        if (isHorizontal) {
          const newWidth = original.width * sizeFactor1;
          const newHeight = original.height * sizeFactor2;
          cage.style.width = `${newWidth}px`;
          cage.style.height = `${newHeight}px`;
          if (cage.classList.contains('cage-top-1') || cage.classList.contains('cage-bottom-1')) {
            const newLeft = original.left + (Math.random() * 20 - 10);
            cage.style.left = `${newLeft}px`;
          };
        } else if (isSideLeft || isSideRight) {
          const newHeight = original.height * sizeFactor1;
          const newWidth = original.width * sizeFactor2;
          cage.style.height = `${newHeight}px`;
          cage.style.width = `${newWidth}px`;
          const deltaHeight = newHeight - original.height;
          const newTop = Math.max(0, original.top - (deltaHeight / 2) + (Math.random() * 20 - 10));
          cage.style.top = `${newTop}px`;
        }
        // Remettre les coins √† leur taille normale
        corners.forEach(corner => {
          if (isHorizontal) {
            corner.style.height = `180%`;
            corner.style.width = `10px`;
          } else if (isSideLeft || isSideRight) {
            corner.style.width = `180%`;
            corner.style.height = `10px`;
          }
        });
      }

      setTimeout(() => {
        updateCageCorners(cage);
      }, 100);

      setTimeout(() => {
        animateCage(cage);
      }, duration);
    }

    // Fonction pour mettre √† jour les positions des coins en fonction de l'animation des cages
    function updateCageCorners(cage) {
      // Les coins restent positionn√©s en relatif, donc rien √† faire ici pour l'instant
    }

    // Mise √† jour de la fonction de d√©tection de collision avec p√©riode de gr√¢ce
    function checkCageCollisions() {
      const cages = document.querySelectorAll('.cage');
      const ballRadius = ballSize / 2;
      const ballCenterX = posX + ballRadius;
      const ballCenterY = posY + ballRadius;

      const now = Date.now();
      let collisionDetected = false;

      cages.forEach(cage => {
        // V√©rifier si cette cage est en p√©riode de cooldown
        if (collisionCooldowns[cage.id] > now) {
          return; // Ignorer cette cage pendant sa p√©riode de cooldown
        }

        // Utiliser getBoundingClientRect pour obtenir les dimensions et positions actuelles
        const cageRect = cage.getBoundingClientRect();

        // V√©rifier si la balle touche une cage
        if (ballCenterX + ballRadius > cageRect.left &&
            ballCenterX - ballRadius < cageRect.right &&
            ballCenterY + ballRadius > cageRect.top &&
            ballCenterY - ballRadius < cageRect.bottom) {

          collisionDetected = true;

          // D√©terminer de quel c√¥t√© la collision a eu lieu
          const dx = ballCenterX - (cageRect.left + cageRect.width / 2);
          const dy = ballCenterY - (cageRect.top + cageRect.height / 2);

          // Rebond en fonction de la direction de la collision
          if (Math.abs(dx) > Math.abs(dy)) {
            // Collision horizontale
            velX *= -0.7;
            if (dx > 0) {
              // Collision √† gauche
              posX = cageRect.right;
            } else {
              // Collision √† droite
              posX = cageRect.left - ballSize;
            }
          } else {
            // Collision verticale
            velY *= -0.7;
            if (dy > 0) {
              // Collision en haut
              posY = cageRect.bottom;
            } else {
              // Collision en bas
              posY = cageRect.top - ballSize;
            }
          }

          // Comparer le gradient de la balle avec celui de la cage (code existant)
          const computedStyle = window.getComputedStyle(cage);
          const cageGradient = computedStyle.backgroundImage;
          const cageColors = cageGradient.match(/(#[0-9A-Fa-f]{6}|rgb\([^)]+\))/gi);

          const ballStyle = window.getComputedStyle(ball);
          const ballGradient = ballStyle.backgroundImage;
          const ballColors = ballGradient.match(/(#[0-9A-Fa-f]{6}|rgb\([^)]+\))/gi);

          // Cr√©er un effet visuel pour montrer le changement de score
          const scoreEffect = document.createElement("div");
          scoreEffect.style.position = "absolute";
          scoreEffect.style.left = `${ballCenterX}px`;
          scoreEffect.style.top = `${ballCenterY - 30}px`;
          scoreEffect.style.fontFamily = "sans-serif";
          scoreEffect.style.fontSize = "20px";
          scoreEffect.style.fontWeight = "bold";
          scoreEffect.style.zIndex = "20";
          scoreEffect.style.transition = "transform 0.5s, opacity 0.5s";

          // Comparer les gradients en utilisant l'apparence visuelle (similaire)
          if (cageColors && ballColors &&
              areSimilarColors(cageColors[0], ballColors[0]) &&
              areSimilarColors(cageColors[1], ballColors[1])) {
            // M√™me gradient, +2 points (au lieu de +1)
            score += 2;
            scoreEffect.textContent = "+2";
            scoreEffect.style.color = "#00FF00";
            pointSound.play(); // Jouer le son lors d'un point gagn√©
          } else {
            // Gradient diff√©rent, -1 point (inchang√©)
            score -= 1;
            scoreEffect.textContent = "-1";
            scoreEffect.style.color = "#FF0000";
          }

          document.body.appendChild(scoreEffect);

          // Animation de l'effet de score
          setTimeout(() => {
            scoreEffect.style.transform = "translateY(-30px)";
            scoreEffect.style.opacity = "0";
          }, 10);

          // Suppression de l'effet apr√®s l'animation
          setTimeout(() => {
            if (scoreEffect.parentNode) {
              document.body.removeChild(scoreEffect);
            }
          }, 600);

          // Mettre √† jour l'affichage du score
          updateScoreDisplay();

          // Changer la couleur de la balle lors d'une collision
          changeBallColor();

          // Mettre la cage en cooldown pour √©viter les collisions multiples rapides
          collisionCooldowns[cage.id] = now + 400;
        }
      });

      return collisionDetected;
    }

    // Ajouter cette fonction pour actualiser les animations r√©guli√®rement
    function updateAnimations() {
      requestAnimationFrame(updateAnimations);
    }
    updateAnimations();

    function startGyro() {
        if (typeof DeviceOrientationEvent.requestPermission === 'function') {
            DeviceOrientationEvent.requestPermission()
                .then(permissionState => {
                    if (permissionState === 'granted') {
                        initGame();
                    } else {
                        info.textContent = "Permission refus√©e ‚ùå";
                        gyroStatus.textContent = "Permission refus√©e ‚ùå";
                        gyroStatus.classList.remove("active");
                        gyroStatus.style.opacity = 1;
                    }
                })
                .catch(console.error);
        } else {
            initGame();
        }
    }

    // Remplacer la fl√®che par une ic√¥ne SVG plus √©l√©gante
    function setGyroStatusActive() {
      // Ic√¥ne SVG "check" stylis√©e, couleur n√©on
      const checkSvg = `<svg width="22" height="22" viewBox="0 0 22 22" style="vertical-align:middle; margin-left:4px;" xmlns="http://www.w3.org/2000/svg"><polyline points="5,12 10,17 17,6" fill="none" stroke="#00ffcc" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
      gyroStatus.innerHTML = `Gyroscope activ√© ${checkSvg}`;
      gyroStatus.classList.add("active");
    }

    // Ajouter cette nouvelle fonction pour initialiser le jeu
    function initGame() {
        enableGyro();
        startBtn.style.display = 'none';
        setGyroStatusActive();

        // Afficher le timer d√®s le d√©but
        timerDisplay.textContent = "00:05";
        timerDisplay.style.color = "white";
        timerDisplay.style.animation = "none";

        // D√©marrer le timer et les animations
        timerSeconds = 5; // 5 secondes pour chaque partie
        timerInterval = setInterval(updateTimer, 1000);
        initCageAnimations();

        // D√©marrer la musique
        backgroundMusic.play();
    }

    function enableGyro() {
      window.addEventListener("deviceorientation", (event) => {
        const gamma = event.gamma || 0;
        const beta = event.beta || 0;

        velX += gamma * accelerationFactor;
        velY += beta * accelerationFactor;
      });

      updateBallPosition();
    }

    startBtn.addEventListener("click", () => {
        startGyro();
        preloadSounds();
    });

    // Pr√©charger les sons d√®s que possible
    function preloadSounds() {
        // Forcer le pr√©chargement des sons en les jouant avec volume √† 0
        backgroundMusic.volume = 0;
        backgroundMusic.play().then(() => {
            backgroundMusic.pause();
            backgroundMusic.currentTime = 0;
            backgroundMusic.volume = 1;
        }).catch(e => console.log("Pr√©chargement de la musique √©chou√©"));

        pointSound.volume = 0;
        pointSound.play().then(() => {
            pointSound.pause();
            pointSound.currentTime = 0;
            pointSound.volume = 1;
        }).catch(e => console.log("Pr√©chargement du son de point √©chou√©"));

        endGameSound.volume = 0;
        endGameSound.play().then(() => {
            endGameSound.pause();
            endGameSound.currentTime = 0;
            endGameSound.volume = 1;
        }).catch(e => console.log("Pr√©chargement du son de fin √©chou√©"));
    }

    // Fonction pour jouer le son de fin avec plusieurs tentatives
    function playEndGameSound() {
        // Premi√®re tentative imm√©diate
        endGameSound.play().catch(error => {
            console.log("Premi√®re tentative √©chou√©e, nouvelle tentative dans 300ms");
            
            // Deuxi√®me tentative apr√®s un d√©lai
            setTimeout(() => {
                endGameSound.play().catch(error => {
                    console.log("Deuxi√®me tentative √©chou√©e, derni√®re tentative dans 500ms");
                    
                    // Derni√®re tentative avec un d√©lai plus long
                    setTimeout(() => {
                        endGameSound.play().catch(e => {
                            console.log("Toutes les tentatives ont √©chou√©, ajout d'un bouton son");
                            
                            // Ajout d'un bouton sp√©cial pour jouer le son
                            const soundBtn = document.createElement("button");
                            soundBtn.textContent = "üîä √âcouter le son de fin";
                            soundBtn.style.position = "absolute";
                            soundBtn.style.top = "10px";
                            soundBtn.style.left = "50%";
                            soundBtn.style.transform = "translateX(-50%)";
                            soundBtn.style.zIndex = "2000";
                            soundBtn.style.padding = "8px 16px";
                            soundBtn.style.backgroundColor = "#00ffcc";
                            soundBtn.style.color = "#111";
                            soundBtn.style.border = "none";
                            soundBtn.style.borderRadius = "8px";
                            soundBtn.style.fontWeight = "bold";
                            soundBtn.style.cursor = "pointer";
                            
                            soundBtn.addEventListener("click", () => {
                                endGameSound.play();
                                soundBtn.remove();
                            });
                            
                            document.querySelector(".score-container").appendChild(soundBtn);
                        });
                    }, 500);
                });
            }, 300);
        });
    }

    // Fonction pour mettre √† jour le timer
    function updateTimer() {
        if (timerSeconds <= 0) {
            endGame();
            return;
        }

        timerSeconds--;
        const minutes = Math.floor(timerSeconds / 60);
        const seconds = timerSeconds % 60;
        timerDisplay.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;

        if (timerSeconds <= 30) {
            timerDisplay.style.color = "#FF0000";
            if (timerSeconds <= 10) {
                timerDisplay.style.animation = "blink 0.5s infinite alternate";
            }
        }
    }

    function endGame() {
        clearInterval(timerInterval);
        gameActive = false;
        
        // 1. Animation de disparition des cages
        const cages = document.querySelectorAll('.cage');
        cages.forEach((cage, index) => {
            setTimeout(() => {
                cage.style.transition = "opacity 0.5s ease-out, transform 0.5s ease-out";
                cage.style.opacity = "0";
                cage.style.transform = "scale(0.8)";
            }, index * 50); // D√©lai progressif pour effet en cascade
        });
        
        // 2. Animation de disparition des coins des cages
        const corners = document.querySelectorAll('.cage-corner');
        corners.forEach((corner, index) => {
            setTimeout(() => {
                corner.style.transition = "opacity 0.5s ease-out";
                corner.style.opacity = "0";
            }, index * 30); // D√©lai plus court pour les coins
        });
        
        backgroundMusic.pause();
        backgroundMusic.currentTime = 0;
        
        // Pr√©parer l'affichage du score
        finalScoreValue.textContent = score;
        
        // Attendre que les animations de disparition soient termin√©es avant d'afficher le score
        setTimeout(() => {
            // Afficher l'overlay du score apr√®s la disparition des cages
            scoreOverlay.classList.add("active");
            
            // Attendre que l'overlay soit visible avant de jouer le son (d√©lai de 800ms)
            setTimeout(() => {
                playEndGameSound();
            }, 800);
        }, 700); // D√©lai pour laisser le temps aux animations de disparition de se terminer
        
        // R√©initialiser le jeu
        score = 0;
        updateScoreDisplay();
        timerSeconds = 5; // Remettre √† 5 secondes pour la prochaine partie
        timerDisplay.textContent = "00:05";
        timerDisplay.style.color = "white";
        timerDisplay.style.animation = "none";
        
        // Indiquer que c'est le jeu de la page 1 qui est termin√©
        localStorage.setItem("game-page", "page1");
        localStorage.setItem("game-state", "finished");
    }
  </script>
</body>
</html>