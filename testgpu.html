<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
<title>Grille + rectangle central avec CGU</title>
<style>
@font-face {
  font-family: 'AMORIA';
  src: url('AMORIA.otf') format('opentype');
  font-weight: normal;
  font-style: normal;
}
html, body {
  height: 100%;
  margin: 0;
  padding: 0;
  overflow: hidden !important;
  background: #111;
  /* Empêche le scroll sur mobile */
  touch-action: none;
}
body {
  width: 100vw;
  height: 100vh;
  position: relative;
  overflow: hidden !important;
}
#canvas {
  position: absolute;
  inset: 0;
  width: 100vw;
  height: 100vh;
  z-index: 0;
  display: block;
}
.center-rect {
  position: absolute;
  left: 50%;
  top: 50%;
  width: 320px;
  height: 260px;
  background: rgba(0,0,0,0.7);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 8px;
  transform: translate(-50%, -50%);
  z-index: 2;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: flex-start;
  padding: 10px 16px;
  box-sizing: border-box;
  /* Police par défaut plus lisible */
  font-family: 'Inter', Arial, sans-serif;
  color: #fff;
  overflow: hidden;
}

.center-rect h1 {
  font-family: 'AMORIA', serif;
  font-size: 2.2em;
  margin-bottom: 15px;
  margin-top: 5px;
  letter-spacing: 0.04em;
  text-align: center;
}

.center-rect h2 {
  font-size: 1.1em;
  margin-top: 10px;
  margin-bottom: 8px;
  font-family: 'Inter', Arial, sans-serif;
  font-weight: 600;
}

.center-rect p {
  font-size: 0.92em;
  text-align: center;
  margin: 8px 0;
  line-height: 1.5;
  font-family: 'Inter', Arial, sans-serif;
}

#cgu-buttons {
  display: flex;
  gap: 10px;
  margin-top: 15px;
}

.cgu-button {
  background: rgba(255,255,255,0.15);
  color: #fff;
  border: 1px solid rgba(255,255,255,0.3);
  border-radius: 4px;
  padding: 8px 15px;
  font-family: 'Inter', Arial, sans-serif;
  font-size: 0.95em;
  cursor: pointer;
  transition: all 0.2s ease;
}

.cgu-button:hover {
  background: rgba(255,255,255,0.25);
}

@media (max-width: 600px) {
  .center-rect {
    width: 75vw;
    max-width: 85vw;
    height: auto;
    min-height: 120px;
    padding: 8px 10px;
  }
  
  .center-rect h1 {
    font-size: 1.2em;
    margin-bottom: 8px;
  }
  
  .center-rect h2 {
    font-size: 0.8em;
    margin-top: 6px;
    margin-bottom: 4px;
  }
  
  .center-rect p {
    font-size: 0.7em;
    line-height: 1.2;
  }
  
  .cgu-button {
    font-size: 0.75em;
    padding: 5px 10px;
  }
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div class="center-rect">
  <h1>Chroméa</h1>
  <h2>Conditions Générales d'Utilisation</h2>
  <p>En accédant à cette animation, vous acceptez les conditions suivantes :<br>
   Il s'agit d'une expérience visuelle générative à titre expérimental.<br>
   Aucune donnée personnelle n'est collectée.</p>
  <div id="cgu-buttons">
    <button class="cgu-button" onclick="acceptCGU()">Accepter</button>
    <button class="cgu-button" onclick="refuseCGU()">Refuser</button>
  </div>
</div>

<script>
// Fonction pour gérer l'acceptation des CGU
function acceptCGU() {
  const centerRect = document.querySelector('.center-rect');
  centerRect.innerHTML = '<h1>Chroméa</h1>';
  centerRect.style.height = '180px';
  centerRect.style.background = 'rgba(0,0,0,0)';
  centerRect.style.border = '0';
}

// Fonction pour gérer le refus des CGU
function refuseCGU() {
  alert("Vous devez accepter les CGU pour accéder à l'expérience.");
}

const canvas = document.getElementById("canvas");
const ctx = canvas.getContext("2d");
// Configuration responsive
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
// Ajuster la taille des cercles en fonction du dispositif
const baseRadius = isMobile ? 10 : 14;
let radius = baseRadius;
let diameter = radius * 2;
const colors = ["#00A993", "#E68B4A", "#7A1619", "#362777", "#EB7AAE",
"#0069AA", "#DC0C15", "#E03A8D", "#FFFFFF", "#2A4899"];
const gradientMap = {
  "#00A993": "#E68B4A", "#E68B4A": "#7A1619", "#7A1619": "#362777",
  "#362777": "#EB7AAE", "#EB7AAE": "#0069AA", "#0069AA": "#DC0C15",
  "#DC0C15": "#E03A8D", "#E03A8D": "#FFFFFF", "#FFFFFF": "#2A4899",
  "#2A4899": "#00A993"
};
let colorGrid = [];
let linearGradientZones = new Map();
let disappearing = [];
let hiddenCircles = new Set();
let blinkingCircles = new Set();

function resizeCanvas() {
  const dpr = window.devicePixelRatio || 1; // Récupérer le ratio de pixels de l'appareil
  canvas.width = window.innerWidth * dpr;
  canvas.height = window.innerHeight * dpr;
  canvas.style.width = `${window.innerWidth}px`;
  canvas.style.height = `${window.innerHeight}px`;
  ctx.scale(dpr, dpr); // Adapter le contexte au ratio de pixels
  
  // Ajuster dynamiquement le rayon en fonction de la taille de l'écran
  if (isMobile) {
    const desiredCirclesWidth = window.innerWidth < 380 ? 12 : 15;
    radius = Math.min(16, Math.floor(window.innerWidth / desiredCirclesWidth / 2));
  } else {
    radius = baseRadius;
  }
  diameter = radius * 2;
  
  // Calculer le nombre de colonnes et lignes avec une marge de sécurité
  const cols = Math.ceil(canvas.width / diameter / dpr); 
  const rows = Math.ceil(canvas.height / diameter / dpr);
  
  colorGrid = new Array(rows).fill().map(() => new Array(cols).fill(null));
  
  // Générer la grille sur toute la surface (plus de borderMargin)
  for (let y = 0; y < rows; y++) {
    for (let x = 0; x < cols; x++) {
      const neighbors = getNeighborColors(x, y);
      let chosenColor;
      if (neighbors.length > 0 && Math.random() < 0.8) {
        chosenColor = neighbors[Math.floor(Math.random() * neighbors.length)];
      } else {
        chosenColor = colors[Math.floor(Math.random() * colors.length)];
      }
      colorGrid[y][x] = chosenColor;
    }
  }
  
  chooseLinearGradientZones();

  // --- Début du traitement des ronds de bord ---
  const visited = new Set();

  function eraseConnected(x, y, colorA, colorB) {
    const stack = [[x, y]];
    while (stack.length) {
      const [cx, cy] = stack.pop();
      const key = `${cx},${cy}`;
      if (visited.has(key)) continue;
      if (
        cx < 0 || cx >= cols ||
        cy < 0 || cy >= rows
      ) continue;
      const c = colorGrid[cy][cx];
      if (c !== colorA && c !== colorB) continue;
      visited.add(key);

      // Ajouter le cercle à la liste des cercles en disparition
      if (!hiddenCircles.has(key)) {
        hiddenCircles.add(key);
        disappearing.push({ x: cx, y: cy, start: performance.now() });
      }

      // Parcours 8 directions
      for (let dx = -1; dx <= 1; dx++) {
        for (let dy = -1; dy <= 1; dy++) {
          if (dx !== 0 || dy !== 0) stack.push([cx + dx, cy + dy]);
        }
      }
    }
  }

  // Pour chaque bord, détecter les couleurs et effacer les zones connectées
  for (let y = 0; y < rows; y++) {
    for (const x of [0, cols - 1]) {
      const c = colorGrid[y][x];
      if (!c) continue;
      const c2 = gradientMap[c.toUpperCase()] || c;
      eraseConnected(x, y, c, c2);
    }
  }
  for (let x = 0; x < cols; x++) {
    for (const y of [0, rows - 1]) {
      const c = colorGrid[y][x];
      if (!c) continue;
      const c2 = gradientMap[c.toUpperCase()] || c;
      eraseConnected(x, y, c, c2);
    }
  }
  // --- Fin du traitement des ronds de bord ---
}

function getNeighborColors(cx, cy) {
  const neighborColors = [];
  for (let dy = -1; dy <= 0; dy++) {
    for (let dx = -1; dx <= 1; dx++) {
      const nx = cx + dx;
      const ny = cy + dy;
      if (nx >= 0 && ny >= 0 && ny < colorGrid.length && nx < colorGrid[0].length) {
        const color = colorGrid[ny][nx];
        if (color) neighborColors.push(color);
      }
    }
  }
  return neighborColors;
}

function getZone(x, y, targetColor) {
  const visited = new Set();
  const queue = [[x, y]];
  const zone = new Set();
  while (queue.length > 0) {
    const [cx, cy] = queue.shift();
    const key = `${cx},${cy}`;
    if (visited.has(key)) continue;
    visited.add(key);
    if (colorGrid[cy]?.[cx] === targetColor) {
      zone.add(key);
      for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
          if (dx !== 0 || dy !== 0) {
            queue.push([cx + dx, cy + dy]);
          }
        }
      }
    }
  }
  return zone;
}

function chooseLinearGradientZones() {
  linearGradientZones.clear();
  const zonesToConvert = isMobile ? 100 : 200; // Moins de zones sur mobile pour de meilleures performances
  const maxAttempts = 200;
  let attempts = 0;
  while (linearGradientZones.size < zonesToConvert && attempts < maxAttempts) {
    const x = Math.floor(Math.random() * colorGrid[0].length);
    const y = Math.floor(Math.random() * colorGrid.length);
    const color = colorGrid[y][x];
    const zone = getZone(x, y, color);
    if (zone.size > 5) {
      const baseAngle = Math.random() * 2 * Math.PI;
      const phaseOffset = Math.random() * Math.PI * 2;
      // Décider du type d'animation pour cette zone (30% de progression linéaire, 70% oscillation)
      const animationType = Math.random() < 0.3 ? 'progression' : 'oscillation';
      // Paramètres communs
      const animationSpeed = 0.5 + Math.random() * 1.5;
      // Paramètres spécifiques à l'oscillation
      const oscillationAmount = Math.PI / 4 + Math.random() * Math.PI / 4;
      let zoneCount = 0;
      for (const key of zone) {
        if (!linearGradientZones.has(key)) {
          linearGradientZones.set(key, {
            baseAngle,
            phaseOffset,
            animationType,
            animationSpeed,
            oscillationAmount
          });
          zoneCount++;
        }
        if (zoneCount > 10 + Math.random() * 20) break;
      }
    }
    attempts++;
  }
}

function optimizeRendering(time) {
  // Supprimer la limitation de fréquence pour une animation plus fluide
  animate(time);
  requestAnimationFrame(optimizeRendering);
}

function animate(time) {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  const t = time / 1000; // Temps en secondes pour des calculs plus fluides
  
  // Récupérer les dimensions du rectangle central pour éviter d'y dessiner des cercles
  const centerRect = document.querySelector('.center-rect').getBoundingClientRect();
  const rectLeft = centerRect.left;
  const rectRight = centerRect.right;
  const rectTop = centerRect.top;
  const rectBottom = centerRect.bottom;
  
  for (let y = 0; y < colorGrid.length; y++) {
    for (let x = 0; x < colorGrid[0].length; x++) {
      const baseColor = colorGrid[y][x];
      if (!baseColor) continue; // Ne pas dessiner si pas de couleur
      
      const key = `${x},${y}`;
      let cx = x * diameter + radius;
      let cy = y * diameter + radius;
      
      // Vérifier si le cercle est à l'intérieur du rectangle central
      if (cx >= rectLeft && cx <= rectRight && cy >= rectTop && cy <= rectBottom) {
        continue; // Ne pas dessiner ce cercle
      }
      
      let r = radius;
      const anim = disappearing.find(a => a.x === x && a.y === y);

      // Si le cercle est en train de disparaître, réduire son rayon progressivement
      if (anim) {
        const elapsed = time - anim.start;
        r *= 1 - elapsed / 400; // Réduction progressive sur 400ms
        ctx.globalAlpha = 1 - elapsed / 400; // Réduction de l'opacité

        if (elapsed > 400) {
          // Une fois l'animation terminée, ajouter le cercle à la liste des clignotants
          blinkingCircles.add(key);
          disappearing = disappearing.filter(a => a !== anim);
          continue;
        }
      }
      
      // Si le cercle est en train de clignoter
      if (blinkingCircles.has(key)) {
        const blinkOpacity = 0.5 + 0.5 * Math.sin(t * 5); // Oscillation entre 0.5 et 1
        ctx.globalAlpha = blinkOpacity;
      }
      
      const endColor = gradientMap[baseColor.toUpperCase()] || baseColor;
      let gradient;
      
      if (linearGradientZones.has(key)) {
        const gradientInfo = linearGradientZones.get(key);
        const { baseAngle, phaseOffset, animationType, animationSpeed, oscillationAmount } = gradientInfo;
        let currentAngle, position;
        
        // Animation différente selon le type d'animation
        if (animationType === 'progression') {
          position = ((t * animationSpeed + phaseOffset) % (Math.PI * 2)) / (Math.PI * 2);
          
          // Créer le dégradé qui se déplace à travers le cercle
          gradient = ctx.createLinearGradient(
            cx - Math.cos(baseAngle) * r,
            cy - Math.sin(baseAngle) * r,
            cx + Math.cos(baseAngle) * r,
            cy + Math.sin(baseAngle) * r
          );
        } else {
          // Animation d'oscillation
          currentAngle = baseAngle + Math.sin(t * animationSpeed + phaseOffset) * oscillationAmount;
          const dx = Math.cos(currentAngle) * r;
          const dy = Math.sin(currentAngle) * r;
          gradient = ctx.createLinearGradient(cx - dx, cy - dy, cx + dx, cy + dy);
        }
      } else {
        const pulse = 0.3 + 0.2 * Math.sin(t + (x + y) / 5);
        gradient = ctx.createRadialGradient(cx, cy, r * pulse, cx, cy, r);
      }
      
      gradient.addColorStop(0, baseColor);
      gradient.addColorStop(1, endColor);
      ctx.fillStyle = gradient;
      ctx.beginPath();
      ctx.arc(cx, cy, r, 0, Math.PI * 2);
      ctx.fill();
      ctx.globalAlpha = 1; // Réinitialiser l'opacité
    }
  }
}

// Fonction utilitaire pour limiter les appels de redimensionnement
function debounce(func, wait) {
  let timeout;
  return function() {
    const context = this;
    const args = arguments;
    clearTimeout(timeout);
    timeout = setTimeout(() => {
      func.apply(context, args);
    }, wait);
  };
}

// Initialisation
window.addEventListener("load", () => {
  window.addEventListener("resize", debounce(resizeCanvas, 250));
  resizeCanvas();
  requestAnimationFrame(optimizeRendering);
});
</script>
</body>
</html>